[
    {
        "type": "message",
        "user": "U2Y2V95D2",
        "text": "Dear, we tried car-lease-demo example from IBM. It seems the ACCESS RIGHTS is on Function-Code-Level instead of Data-Level, right? How do we do ACCESS RIGHTS on different Data access? Thank you. (For example, data record 1 can be read by user A only. data record 2 can be read by user B only etc.) Thank you.",
        "ts": "1479121565.002322"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "what do you want to achieve?",
        "ts": "1479128776.002323"
    },
    {
        "type": "message",
        "user": "U2Y2V95D2",
        "text": "I want to make different data private to some groups of people",
        "ts": "1479136093.002324"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but you know that all VPs see all data",
        "ts": "1479138248.002325"
    },
    {
        "type": "message",
        "user": "U0ZR63HLK",
        "text": "<@U2Y2V95D2>, that can be implemented iin the same way it is implemented for function access control",
        "ts": "1479141727.002326"
    },
    {
        "type": "message",
        "user": "U0ZR63HLK",
        "text": "you might want to apply this access control check during a query",
        "ts": "1479141748.002327"
    },
    {
        "type": "message",
        "user": "U0ZR63HLK",
        "text": "if an entity is query a certain data field, the chaincode will enforce access control",
        "ts": "1479141779.002328"
    },
    {
        "type": "message",
        "user": "U0ZJZBJLF",
        "text": "Hi.\n<https:\/\/github.com\/hyperledger\/fabric\/blob\/master\/gossip\/api\/channel.go>\nIn order to support multi-channels, the gossip component needs 2 methods from the MSP (or should I say, the guys that implement the MSP?)\n```\n\t\/\/ IsInMyOrg returns whether the given peer's certificate represents\n\t\/\/ a peer in the invoker's organization\n\tIsInMyOrg(PeerCert) bool\n\n\t\/\/ Verify verifies a JoinChannelMessage, returns nil on success,\n\t\/\/ and an error on failure\nVerify(JoinChannelMessage) error\n```\nIs that possible to implement?",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "hyperledger\/fabric",
                "title_link": "https:\/\/github.com\/hyperledger\/fabric\/blob\/master\/gossip\/api\/channel.go",
                "text": "Read-only mirror of <https:\/\/gerrit.hyperledger.org\/r\/#\/admin\/projects\/fabric>",
                "fallback": "GitHub: hyperledger\/fabric",
                "thumb_url": "https:\/\/avatars3.githubusercontent.com\/u\/7657900?v=3&s=400",
                "from_url": "https:\/\/github.com\/hyperledger\/fabric\/blob\/master\/gossip\/api\/channel.go",
                "thumb_width": 142,
                "thumb_height": 142,
                "service_icon": "https:\/\/github.com\/apple-touch-icon.png",
                "id": 1
            }
        ],
        "edited": {
            "user": "U0ZJZBJLF",
            "ts": "1479146918.000000"
        },
        "ts": "1479146843.002329"
    },
    {
        "type": "message",
        "user": "U0ZJZBJLF",
        "text": "The JoinChannel message, if it's not clear- is the genesis configuration block sent from the SDK to the peers when a channel is either created or modified",
        "ts": "1479146892.002331"
    },
    {
        "user": "U2X9KDDL7",
        "text": "<@U2X9KDDL7|vdods> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1479156547.002333"
    },
    {
        "type": "message",
        "user": "U2X9KDDL7",
        "text": "Hi all, I'm wondering if there has been any thought put into (or perhaps an existing solution, be it external or part of Hyperledger) massive key management?  By that I mean managing many keys per user, say on the order of 1 million keys.",
        "ts": "1479157763.002334"
    },
    {
        "type": "message",
        "user": "U2X9KDDL7",
        "text": "One of the motivations here being limiting the damage done in the case of a compromised key by limiting the number of transactions a key can be used for, thereby necessitating management of many keys (for one user).",
        "ts": "1479157839.002335"
    },
    {
        "type": "message",
        "user": "U2Y2V95D2",
        "text": "Thanks <@U0ZR63HLK> and <@U0XR6J961> .",
        "ts": "1479177627.002336"
    },
    {
        "user": "U1HBFGDPV",
        "text": "<@U1HBFGDPV|silentspark> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1479187381.002337"
    }
]