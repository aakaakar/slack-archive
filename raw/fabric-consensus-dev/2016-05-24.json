[
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "<@U0XPR4NP4> are <https:\/\/github.com\/hyperledger\/fabric\/issues\/1538> and <https:\/\/github.com\/hyperledger\/fabric\/issues\/1091> really consensus related?",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "Consensus sieve has error on both LoZ and X86 platforms -- one peer cannot get block  \u00b7 Issue #1538 \u00b7 hyperledger\/fabric \u00b7 GitHub",
                "title_link": "https:\/\/github.com\/hyperledger\/fabric\/issues\/1538",
                "text": "Description Get the latest hyper ledger code (commit 66ca505 ) Run with busywork and get error from peers. After tested with @bcbrock , he confirmed that this is bug with sieve on LoZ platform....",
                "fallback": "GitHub: Consensus sieve has error on both LoZ and X86 platforms -- one peer cannot get block  \u00b7 Issue #1538 \u00b7 hyperledger\/fabric",
                "thumb_url": "https:\/\/avatars3.githubusercontent.com\/u\/12942488?v=3&s=400",
                "from_url": "https:\/\/github.com\/hyperledger\/fabric\/issues\/1538",
                "thumb_width": 420,
                "thumb_height": 420,
                "id": 1
            },
            {
                "service_name": "GitHub",
                "title": "REST API \/chain\/blocks\/&lt;n&gt; returns empty blocks (other than block 0) \u00b7 Issue #1091 \u00b7 hyperledger\/fabric \u00b7 GitHub",
                "title_link": "https:\/\/github.com\/hyperledger\/fabric\/issues\/1091",
                "text": "This issue is observed in conjunction with another error case, see #920. When a test program makes the REST API call \/chain\/blocks\/, it gets a normal HTTP response but the data is NULL, i.e., the b...",
                "fallback": "GitHub: REST API \/chain\/blocks\/ returns empty blocks (other than block 0) \u00b7 Issue #1091 \u00b7 hyperledger\/fabric",
                "thumb_url": "https:\/\/avatars2.githubusercontent.com\/u\/11968347?v=3&s=400",
                "from_url": "https:\/\/github.com\/hyperledger\/fabric\/issues\/1091",
                "thumb_width": 400,
                "thumb_height": 400,
                "id": 2
            }
        ],
        "ts": "1464077576.002307"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "they might as well be - but this is not immediate\/obvious",
        "ts": "1464077591.002309"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "<@U0ULK2JPP>: you are working \"time, crontab\"? what's this?",
        "ts": "1464078825.002310"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "<@U0XR6J961> : more like \u201cplaying with\u201d. A time service using consensus based on <@U0XRC0KLH>\u2019s idea (a while back)",
        "ts": "1464089276.002311"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ah",
        "ts": "1464089537.002312"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "how does it work?",
        "ts": "1464089540.002313"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "basically a service will create  \u201cupdate\u201d time transactions periodically (at some granularity of seconds, say 1 second) on a system chaincode. If everyone consents based on accuracy within limits on their local clock time, that will serve as a global time. The time has to be coarse grained ( not msecs for example)\u2026.",
        "ts": "1464089942.002314"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "everyone?",
        "ts": "1464089976.002315"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "the devil will be in the details :slightly_smiling_face: but it is an interesting approach",
        "ts": "1464089978.002316"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "or 2f+1?",
        "ts": "1464089979.002317"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "2f+1",
        "ts": "1464089990.002318"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "how do you tie in the validation?",
        "ts": "1464089994.002319"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "what happens if the service stops updating the time?",
        "ts": "1464090005.002320"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "Guardtime, my company, has a product that does exactly that (among other things)",
        "ts": "1464090054.002321"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "and can be cryptographically verified out of band",
        "ts": "1464090091.002322"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "there could be copies of  services",
        "ts": "1464090109.002323"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "if that is a requirement, I would suggest we may have a ready solution",
        "ts": "1464090126.002324"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "interesting - how would that go into hyperledger?",
        "ts": "1464090164.002325"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "muralisr: i'm working on periodic null requests right now",
        "ts": "1464090236.002326"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "<@U0XR6J961>: goroutine(s) built into the fabric for initiating transactions and a system chaincode",
        "ts": "1464090241.002327"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "muralisr: that was directed to jamie.steiner",
        "ts": "1464090276.002328"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "muralisr: i'm wondering - what about all consensus nodes attaching their idea of time to packets",
        "ts": "1464090327.002329"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "(with signature)",
        "ts": "1464090332.002330"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "<@U0KM0C3M3>: there\u2019s an issue that covers this broadly (@simone do you have the issue you created handy ?)",
        "ts": "1464090371.002331"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and then the leader compiles a list of times, which allows bounding the idea of time as \"somewhere between this and that value\"",
        "ts": "1464090375.002332"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "access is available via an http service",
        "ts": "1464090380.002333"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "although it is probably better not to attach it to the consensus service directly",
        "ts": "1464090403.002334"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "we have a developer program which could be used to evaluate it: <https:\/\/guardtime.com\/blockchain-developers>",
        "attachments": [
            {
                "title": "KSI Blockchain for Developers | Guardtime",
                "title_link": "https:\/\/guardtime.com\/blockchain-developers",
                "text": "KSI blockchain is built to be integrated into our digital lives and we have created the components for making the integrations easy. We have also made the KSI blockchain service available for non-commercial use by developers. \u00a0",
                "fallback": "KSI Blockchain for Developers | Guardtime",
                "from_url": "https:\/\/guardtime.com\/blockchain-developers",
                "id": 1
            }
        ],
        "ts": "1464090422.002335"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "happy to get some of our developers to assist - <@U14FDQAS3> would be a good resource",
        "edited": {
            "user": "U0KM0C3M3",
            "ts": "1464090480.000000"
        },
        "ts": "1464090437.002337"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "jamie.steiner: i don't think that would work - the time keeping component needs to be part of hyperledger",
        "ts": "1464090447.002338"
    },
    {
        "user": "U14FDQAS3",
        "inviter": "U0KM0C3M3",
        "type": "message",
        "subtype": "channel_join",
        "text": "<@U14FDQAS3|ristoalas> has joined the channel",
        "ts": "1464090503.002340"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "muralisr: i suggested that peers compete in proposing the next time",
        "ts": "1464090506.002341"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "<@U0XR6J961> yes. That\u2019s also an option\u2026 the time service would be on every peer",
        "ts": "1464090541.002342"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "I would have thought time is the kind of thing an external oracle would be useful for",
        "ts": "1464090543.002343"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but then, do we want to record thousands of transactions a day that just update the time?",
        "ts": "1464090544.002344"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "exactly",
        "ts": "1464090550.002345"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "jamie.steiner: i don't think we should build a generic platform that is tied to one company's service",
        "ts": "1464090578.002346"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "and in the end we also need this to work closely with crontab",
        "ts": "1464090578.002347"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "what if your company disappears - suddenly all hyperledger blockchains stop working",
        "ts": "1464090604.002348"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "loosely couple approach via a system chaincode helps us at least play with this",
        "ts": "1464090627.002349"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "muralisr: what is crontab in this scenario?",
        "ts": "1464090639.002350"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "basically allows users to specifiy \u201crun tx-A at this time\"",
        "ts": "1464090675.002351"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "think timer-wheel going over transactions to run",
        "ts": "1464090693.002352"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "triggers",
        "ts": "1464090722.002353"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and who triggers the transaction?",
        "ts": "1464090725.002354"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "which peer",
        "ts": "1464090727.002355"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "same thing as today. The peer to which the transaction is submitted will hold the crontab entry",
        "ts": "1464090763.002356"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "as far as I am aware, a number of functions are designed to be pluggable, based on the deployment and the requirements.  It seems like one option could be to offer an external oracle for time.  Even the base consensus algorithm is more-or-less pluggable, right?",
        "ts": "1464090772.002357"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "muralisr: so the local peer",
        "ts": "1464090791.002358"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "correct",
        "ts": "1464090802.002359"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "im not trying to create a dependency, just offering our expertise.",
        "ts": "1464090809.002360"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "jamie.steiner: the aspiration is to make it pluggable",
        "ts": "1464090811.002361"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "jamie.steiner: the difficulty is not the external oracle, but trusting its data and the way it has been introduced into the system",
        "ts": "1464090860.002362"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "jamie.steiner: otherwise we could just use ntp",
        "ts": "1464090868.002363"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "muralisr: but that notion of time would be independent of the chaincode's notion of time",
        "ts": "1464090886.002364"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "muralisr: what happens if that peer goes down or suffers network outage, etc?",
        "ts": "1464090905.002365"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "chaincode would have to have an API to on the shim to get the time",
        "ts": "1464090988.002366"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "it's not similar to using ntp - in this case it would function as a TTS that does not require trust in a root certificate.",
        "edited": {
            "user": "U0KM0C3M3",
            "ts": "1464091028.000000"
        },
        "ts": "1464091007.002367"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "happy to discuss offline, if you are interested in evaluating the approach.",
        "edited": {
            "user": "U0KM0C3M3",
            "ts": "1464091057.000000"
        },
        "ts": "1464091038.002369"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "why offline?",
        "ts": "1464091091.002371"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "this is perfect",
        "ts": "1464091096.002372"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "the problem is that even if time comes from one oracle, how do you know that you can trust the entity that took the time from the oracle, and gave you the right value?",
        "ts": "1464091132.002373"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "and the time service would be across validators ( skewed on a random sleep )",
        "ts": "1464091133.002374"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "here is fine as well.  will have to come back after a while though, i have a call",
        "ts": "1464091138.002375"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "it could have delayed the message for an arbitrary time",
        "ts": "1464091146.002376"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "a particular message, is submitted to our service, gets a time associated with it that is universal.",
        "ts": "1464091179.002377"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "in the end, the idea is to have something loosely coupled and easy enough to work with for everyone",
        "ts": "1464091202.002378"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "built upon  and using fabric\u2019s mechanisms such as consensus",
        "ts": "1464091228.002379"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i'm interested in the specific implementation",
        "ts": "1464091251.002380"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so the crontab is just a \"submit this transaction after time X\"",
        "ts": "1464091267.002381"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "that's the equivalent to the bitcoin mempool, in a way",
        "ts": "1464091278.002382"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "\u201caround time X\u201d is more accurate I think",
        "ts": "1464091289.002383"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "what does \"around\" mean?",
        "ts": "1464091312.002384"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "won\u2019t be at 11.01.22.536 exactly \u2026 but between 11.02.22 and 11.02.24",
        "ts": "1464091364.002385"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so after 11.02.22",
        "ts": "1464091371.002386"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "within tolerance",
        "ts": "1464091383.002387"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "that's too vague for me",
        "ts": "1464091394.002388"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "really ? well,  tolerance is just so we build the system to be not too finegrained. Idea being that in the end the execution of transactions cannot be accurately set for time, why make it a requirement that it should be initiated at an exact time",
        "ts": "1464091550.002389"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "the crontab has to do work and the tolerance just gives us the room to do it",
        "ts": "1464091593.002390"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i didn't say initiated at an exact time",
        "ts": "1464091696.002391"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i said after some specific time",
        "ts": "1464091708.002392"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "right",
        "ts": "1464091740.002393"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "also do you want to trigger the transaction based on real world time, or based on agreed-upon chaincode time?",
        "ts": "1464091768.002394"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and why",
        "ts": "1464091770.002395"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "you mean the \u201ccrontab\u201d transaction ?",
        "ts": "1464092063.002396"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "that\u2019s just a service system provides so users can initiated a transaction based on system time",
        "ts": "1464092113.002397"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "just local time",
        "ts": "1464092204.002398"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ok",
        "ts": "1464092207.002399"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "again this is just something to try out as the implementation is not too hard",
        "ts": "1464092457.002400"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "try out is bad",
        "ts": "1464092965.002401"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "because it doesn't consider all issues that can arise",
        "edited": {
            "user": "U0XR6J961",
            "ts": "1464092992.000000"
        },
        "ts": "1464092982.002402"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "obviously this is not for merge into mainline",
        "ts": "1464093096.002404"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "sure, but what i'm saying is that this needs a requirements doc, etc.",
        "ts": "1464093150.002405"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "e.g. what happens if you submit a request, and the peer crashes and restarts?",
        "ts": "1464093174.002406"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "correct. Theres a persistent component to crontab.",
        "ts": "1464093368.002407"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "as for requirements doc, definitely. The implement is to test the mechanics fairly quickly and fail fast.",
        "ts": "1464093800.002408"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "problem with consensus and security is that you don't fail fast :slightly_smiling_face:",
        "ts": "1464097741.002409"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "haha..you could be right",
        "ts": "1464097850.002410"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "<@U0XR6J961>: \"the problem is that even if time comes from one oracle, how do you know that you can trust the entity that took the time from the oracle, and gave you the right value?\" can you elaborate?  is the problem that you cant trust the accuracy of the time, or that you cant trust that the entity took some action at that particular moment?",
        "ts": "1464100322.002411"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "either",
        "ts": "1464100347.002412"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "I realize that our solution is specific to my company's service, but I can explain how we solve that problem.  I understand you may feel there is a reason to make a time stamping component that is intrinsic to the hyperledger stack.  If, however, there is a possibility to use an external source as an oracle for time, our service would serve well in that role. \n\nSpecifically, our blockchain creates one block every second, verifiable through public observation that there are 3600 blocks every hour, etc. Any piece of data or action that can be represented as data can be signed, and it's proof of existence at that point in time can be proven.  The trust anchor is widely witnessed evidence that is periodically published in newspapers.  the time can be backed out from that.",
        "ts": "1464100761.002413"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but only for the past",
        "ts": "1464100887.002414"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "not for the current time",
        "ts": "1464100891.002415"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i can not be sure that the time you just published is actually timely - you might have delayed publication by a some time",
        "ts": "1464100933.002416"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but, for a moment, let's assume that you act honestly",
        "ts": "1464100967.002417"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "whatever node that introduces your timestamp into the hyperledger blockchain might just delay your honest timestamp arbitrarily",
        "ts": "1464100994.002418"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "if you are assuming that our service acts honestly, and I present you a signature that relates to a particular time - you must agree agree that this time has passed.",
        "ts": "1464101093.002419"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "no",
        "ts": "1464101110.002420"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "that *at least* this time has passed",
        "ts": "1464101120.002421"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but it could be a day later in fact",
        "ts": "1464101133.002422"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and it is a stale piece of information",
        "ts": "1464101142.002423"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "sure, but if other timestamps from moments after that are known, then the stale nature is obvious.  it seems trivial to sign a piece of data every second and avoid this.",
        "ts": "1464101229.002424"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but all of these signed timestamps could be delayed by a day",
        "ts": "1464101387.002425"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "nobody can tell the difference",
        "ts": "1464101395.002426"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "anyone who has access to the service can get a fresh timestamp and see that it returns in a second.  I'm not sure i understand how it can be delayed.",
        "ts": "1464101653.002427"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "chaincode cannot access the network",
        "ts": "1464101789.002428"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so this needs to be integrated into the hyperledger code",
        "ts": "1464101819.002429"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but different replicas will receive the request at different times",
        "ts": "1464101847.002430"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "at that point, the replicas might as well just look at their local clock",
        "ts": "1464101874.002431"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "hmm, I see.  so the real issue is that the notion of time has to be local to the chaincode, not the node that is executing the chaincode?  I dont agree that the local clock is as good - there is still the notion of an outside, impartial proof of what time is.  It is separate from, and independent from the local clock in a useful way.",
        "ts": "1464101957.002432"
    },
    {
        "type": "message",
        "user": "U0N1D1UAE",
        "text": "<@U0XPR4NP4> Jason, regarding PR #1557, I apologize, I didn\u2019t realize the extent of the problem. I had assumed that the choice was between \u201cstale\u201d and \u201cup-to-date\u201d values. Of course the query should never return garbage.",
        "ts": "1464102014.002433"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "jamie.steiner: but ntp is also impartial",
        "ts": "1464102033.002434"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "bcbrock: that's #1091",
        "ts": "1464102061.002435"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0N1D1UAE>: Not a problem, it's great to have interest to get these things fleshed out, I completely agree we need a better way to communicate this through the API",
        "ts": "1464102085.002436"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "we totally have to",
        "ts": "1464102098.002437"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "it's a long standing problem",
        "ts": "1464102107.002438"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "its accuracy is not independently provable, and an attestation of time by ntp cannot be transferred or verified by a third party",
        "ts": "1464102108.002439"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ntp's accuracy is as provable as your accuracy",
        "ts": "1464102160.002440"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "you say \"look at our past performance, we've been working correctly\"",
        "ts": "1464102192.002441"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "I disagree.  you can choose to trust it locally, if you choose, but you cannot later explain to a third party why you chose that.  an ntp timestamp is just a piece of data",
        "ts": "1464102202.002442"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but that doesn't mean that the current timestamp is not wrong",
        "ts": "1464102204.002443"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "that is correct",
        "ts": "1464102212.002444"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but for a byzantine fault tolerant network, trusting one external oracle is silly anyways",
        "ts": "1464102275.002445"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "inevitably, it has to connect to external events.",
        "ts": "1464102329.002446"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "and oracles will be required.",
        "ts": "1464102341.002447"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "well if i trust an oracle",
        "ts": "1464102362.002448"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "if not for time, then for what LIBOR is, or whether company XYZ defaulted.",
        "ts": "1464102368.002449"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "why don't i just run all the code there",
        "ts": "1464102368.002450"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "then i can skip the whole byzantine threat model",
        "ts": "1464102387.002451"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "I think the problem of trusting code execution is separate from the problem of how a ledger connects to external events.",
        "ts": "1464102471.002452"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "sure",
        "ts": "1464102492.002453"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "the fundamental question is, how do we trust the data that is input",
        "ts": "1464102517.002454"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "if your view is that every trusted event that impacts the state of the ledger must be generated within the ledger, I believe the scope of what can be accomplished is much limited.",
        "ts": "1464102545.002455"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and our answer seems to be \"if enough peers can validate hat the input reflects (approximately) its real value, then it is accepted\"",
        "ts": "1464102573.002456"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "perhaps time is not the best example - im sure you can implement some method to come to consensus around what the time is.",
        "ts": "1464102583.002457"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "another answer is \"if an external trusted entity certifies the fact\"",
        "ts": "1464102625.002458"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i.e. you for time, the FED for interest rates, etc.",
        "ts": "1464102637.002459"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "the devil is in the details - for example, what \" (approximately)\" means for time seems fairly agreeable - it might be harder for LIBOR, but certainly the logic will be different, and the tolerance for different type of data is likely to be hotly contested.",
        "ts": "1464102720.002460"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "correct",
        "ts": "1464102786.002461"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i suggested creating a framework for consenting on external data long ago",
        "ts": "1464102805.002462",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U0KPFAZNF"
                ],
                "count": 1
            }
        ]
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but it was not considered the right approach, i guess",
        "ts": "1464102825.002463"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "<@U0XPR4NP4>, <@U0Y14MWA2>: i'm thinking about how to do periodic null requests, and they are more complicated than you'd think",
        "ts": "1464103019.002464"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "sending a null request is simple, but when do you send it?  or rather, when do you expect that the primary sent one?",
        "ts": "1464103039.002465"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "do you look at when you receive a pre-prepare?",
        "ts": "1464103065.002466"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "or when the request commits or executes",
        "ts": "1464103079.002467"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i guess because of primary, pre-prepare.",
        "ts": "1464103087.002468"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "<@U0XR6J961>: I fully agree with you.  1) oracles are not useful here, and 2) I think we _can_ create a framework for defining consensus on external events (and think, in fact, we have to)",
        "ts": "1464103149.002469"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "this is part of what I was driving at with my comments in <https:\/\/github.com\/hyperledger\/fabric\/pull\/1513>",
        "edited": {
            "user": "U0KPFAZNF",
            "ts": "1464103209.000000"
        },
        "ts": "1464103201.002470"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "For instance, to use system-chaincode as the closest thing to approximate what could be part of the an external-event-framework, I envision these system chaincodes would need to be able to invoke transactions on other chaincode without a tcert context",
        "ts": "1464103301.002473"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "for instance, to emit a time event",
        "ts": "1464103319.002474"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "external data is just a different name for non-determinism",
        "ts": "1464103405.002475"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and it will be real difficult to do that",
        "ts": "1464103432.002476"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XR6J961>: I would think it should be keyed off the commit.  The network is configured to send a null request  pre-prepare one second after the last commit if no new requests have been received.  Then, for the byzantine check, the backups would have some slightly longer timer, say, 2s for how long to allow between completing an execution, and receiving a commit cert for the next execution.",
        "ts": "1464103438.002477"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but that's way in the future",
        "ts": "1464103440.002478"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "jyellick: but the primary only controls pre-prepares, not commits",
        "ts": "1464103470.002479"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but i'm glad you disagree - it's not obvious",
        "ts": "1464103502.002480"
    },
    {
        "type": "message",
        "user": "U0KM0C3M3",
        "text": "i agree that where this conversation ended is largely very theoretical.  I do not believe it will be possible to generate all required data internally",
        "ts": "1464103505.002481"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I'm not convinced that pre-prepare is wrong, but once a pre-prepare has been broadcast (non-byzantinely) we should be guaranteed to get that commit cert.",
        "ts": "1464103591.002482"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I was thinking queue off of commit because its existence is evidence to the fact that the pre-prepare was broadcast in that non-byzantine way",
        "ts": "1464103621.002483"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "As I think about it more, handling the timer off of pre-prepare seems safe, I think they should be equivalent, and off of 'pre-prepare' is more fair to the primary, as only its latency to send to the backups is counted against it, not the network latency.",
        "ts": "1464103771.002484"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yea",
        "ts": "1464103804.002485"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "thanks",
        "ts": "1464103807.002486"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i'll try to implement that",
        "ts": "1464103812.002487"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "jyellick: oh, it's all not so easy",
        "ts": "1464103947.002488"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "what happens if there are no free sequence numbers?",
        "ts": "1464103959.002489"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so maybe commit is better",
        "ts": "1464103964.002490"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "So I think the timer definitely needs to start after execution.  The big thing we cannot do is include the execution time and count it against the 'null timeout'",
        "ts": "1464104014.002491"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XR6J961>: I've started prototyping converting `pbft-core.go` to be more state-machine-y, trying to do it in a PR friendly way in small chunks.  Would like to talk about it when you have some time.",
        "ts": "1464104076.002492"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yea",
        "ts": "1464104091.002493"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "what's your plan?",
        "ts": "1464104095.002494"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "So, essentially, there would be an 'event manager' who's simple task is to have an unbuffered channel, which events get delivered to an event receiver interface whose definition simply requires `processEvent(event interface{}) interface{}`, if `processEvent` returns something that is non-nil, it is treated as a new priority event to be processed next.\n\nSo for instance `pbft-core.go` becomes a `eventReceiver`, and its `processEvent` looks like:\n\n```\nfunc (instance *pbftCore) processEvent(event interface{}) {\n        logger.Debug(\"Replica %d processing event\", instance.id)\n\n        switch ev := event.(type) {\n        case viewChangeTimerEvent:\n                <http:\/\/logger.Info|logger.Info>(\"Replica %d view change timer expired, sending view change\", instance.id)\n                instance.sendViewChange()\n        case messageEvent:\n                msg := ev\n                logger.Debug(\"Replica %d received incoming message from %v\", instance.id, msg.sender)\n                instance.recvMsg(msg.msg, msg.sender)\n        case stateUpdatingEvent:\n                update := ev\n                instance.skipInProgress = true\n                instance.lastExec = update.seqNo\n                instance.moveWatermarks(instance.lastExec) \/\/ The watermark movement handles moving this to a checkpoint boundary\n...\n        case execDoneEvent:\n                instance.execDoneSync()\n        default:\n                logger.Error(\"Replica %d received an unknown message type\", instance.id)\n        }\n}\n```",
        "edited": {
            "user": "U0XPR4NP4",
            "ts": "1464104275.000000"
        },
        "ts": "1464104257.002495"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Then for the plugins, they would also be `eventReciver`s, and they would first process the event, then pass it into PBFT core if they chose to",
        "ts": "1464104302.002497"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "why the return?",
        "ts": "1464104371.002498"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "My concern is overflowing the stack",
        "ts": "1464104381.002499"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so that there is a formalized way?",
        "ts": "1464104386.002500"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "oh, go doesn't do tail calls?",
        "ts": "1464104391.002501"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Not to my knowledge",
        "ts": "1464104399.002502"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "usually compilers do these days",
        "ts": "1464104409.002503"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(But I could be wrong)",
        "ts": "1464104411.002504"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i would implement whatever is easier",
        "ts": "1464104423.002505"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "however, there needs to be an interface to enqueue events (timer events)",
        "ts": "1464104434.002506"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "But generally, I dislike that at the end of `sendViewChange` we call `processNewView`, it seems like it would be clearer if we just injected that as an event",
        "ts": "1464104450.002507"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, I've also worked a little on that",
        "ts": "1464104459.002508"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "timers need to be first class objects supported by the event manager",
        "ts": "1464104472.002509"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The key is timer events need to be cancel-able, and I think I've got that down",
        "ts": "1464104474.002510"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "well, cancelling events is simple",
        "ts": "1464104497.002511"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "you just set a field `cancelled` to `true`",
        "ts": "1464104510.002512"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "It depends on your implementation but isn't necessarily quite that easy, you have the race in that case",
        "ts": "1464104545.002513"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "the event manager will have to maintain its own timer wheel, and pick the next event from that wheel, and post it to `processEvent`",
        "ts": "1464104570.002514"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "```\nif !cancelled {\n  sendEvent()\n}\n```\nWhat if it's canceled after it enters into the (blocking) `sendEvent()` call",
        "ts": "1464104573.002515"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "who could cancel it?",
        "ts": "1464104592.002516"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "only `processEvent` can cancel",
        "ts": "1464104605.002517"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "So, classic case, we're executing a request, and the view change timer expires, then we cancel the view change timer because the execution finished, and we've still got this view change event waiting for us.",
        "ts": "1464104664.002518"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "well no",
        "ts": "1464104685.002519"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "because the event manager will go and wait on `newMessage() || timerExpired()`",
        "ts": "1464104726.002520"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "it will get the timerExpired, but then sees that the timer got cancelled",
        "ts": "1464104742.002521"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so it discards it",
        "ts": "1464104745.002522"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Why not, simply have the timer not send the event if it is reset before the event is read?",
        "ts": "1464104792.002523"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "or that",
        "ts": "1464104807.002524"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "it's all internal to the event manager",
        "ts": "1464104814.002525"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Right.  I liked the idea of pushing the complexity of 'not sending canceled timers' into the timer, rather than into event delivery, but yes, the key is they both happen in the event manager.",
        "ts": "1464104877.002526"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so how do we ingress events?",
        "ts": "1464104902.002527"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "does the public API just enqueue events to the event manager?",
        "ts": "1464104917.002528"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I say the event manager has a thread, the only thread which touches any state, and the public API will simply write events onto the unbuffered channel that event thread reads from",
        "edited": {
            "user": "U0XPR4NP4",
            "ts": "1464104967.000000"
        },
        "ts": "1464104948.002529"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(So, generally, the public API calls would block until the event is delivered)",
        "ts": "1464104994.002531"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes",
        "ts": "1464104997.002532"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so the event manager has two sources of events, its internal timer thing, and \"incoming\" event (channel), which is written to by the public API",
        "ts": "1464105083.002533"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Right.  The channel is of type `interface{}` so you can write whatever event type you want to onto it, which makes it nicely pluggable, then on the other side, the type switch figures out what event it is, and gives you whatever event metadata is required",
        "ts": "1464105143.002534"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I did some brief research, and doing switching based on the type like that is (according to stack overflow) 4-5 times slower than switching on an int, but that still seems plenty fast, the switching is not likely to be our performance bottleneck, and it could be re-written as an int type switch later if we really needed to.",
        "ts": "1464105210.002535"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "how does that integrate with timers?",
        "ts": "1464105212.002536"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i like the way you're switching",
        "ts": "1464105231.002537"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "although an alternative would be to enqueue funcs",
        "ts": "1464105242.002538"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and just execute them",
        "ts": "1464105248.002539"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, I considered the func queue, but this seemed less invasive to the current code, and not obviously worse",
        "ts": "1464105273.002540"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "`chan &lt;- func(){ op.doFoo(arg) }`",
        "ts": "1464105286.002541"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The timer would simply be another type which would get shoved onto the channel.  I figured the manager could provide an interface for registering timer types",
        "ts": "1464105287.002542"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "wait, onto the channel?",
        "ts": "1464105306.002543"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i don't know whether i like that channel API",
        "ts": "1464105336.002544"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i think a `eventManager.Queue(...)` and `eventManager.Timer(duration, ...)` would be more explicit and symmetrical",
        "ts": "1464105411.002545"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "for testing, we would implement a different eventmanager, i guess",
        "ts": "1464105461.002546"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "where timers just don't have any duration, but execute when there is nothing else happening",
        "ts": "1464105485.002547"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "of course the timer events would still be ordered properly",
        "ts": "1464105494.002548"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "the more i think about the null requests, the less happy i am about them",
        "ts": "1464105559.002549"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "watermarks only update when checkpoints are reached",
        "ts": "1464105596.002550"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so that binds in execution",
        "ts": "1464105616.002551"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i don't think null requests are a clear and simple solution",
        "ts": "1464105711.002552"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The channel would not be exposed to the outside world, only internal to the event manager, but because the timers are contained in the event manager, they are free to interact with it directly (which, I just showed <@U0XQ35CDD>, makes for some pretty clean code).  We could have an API on the event manager so that someone like `RecvMsg` could write `manager.Queue(event interface{})` which then blocks on a channel write, or we could have the API call write to the channel directly.  The channel is more flexible, but the API call is maybe more approachable.",
        "ts": "1464106097.002553"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "<@U0XR6J961>: you mentioned external data is non deterministic and thats a problem\u2026.I would argue, thats the point",
        "ts": "1464106243.002554"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "As to null requests, the eventual target would be to actually update watermarks based on sequence numbers from non-checkpoints.  I discussed with <@U0XQ35CDD> this weekend on why the original implementation used checkpoints, but there's nothing preventing it.",
        "ts": "1464106255.002555"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "we want it to go through consensus\u2026",
        "ts": "1464106260.002556"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "if 7 out of 10 nodes agree it is at least May 24 2016 UTC, then it is at least May 24 2016, otherwise it isnt",
        "ts": "1464106314.002557"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "non-deterministic events will never be legitimized\u2026we just need to make sure the system can handle the possibility of their introduction",
        "ts": "1464106356.002558"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "to be clear, the framework would only support the confirmation of events that have some semblance of determinism to them\u2026.the passing of a date, the delivery of a package, the current interest rate by the FED, etc\u2026its the job of the framework to associate consensus around that, not to legitimize random stuff being injected",
        "ts": "1464106529.002559"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "jyellick: so what's the api of the event manager?",
        "ts": "1464107034.002560"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "is it `Queue(interface{}), Timer(duration, interface{}) someTimerObj), Cancel(someTimerObjType)`?",
        "ts": "1464107094.002561"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XR6J961>: Not yet finalized, but I'm not certain there needs to be anything other than `Queue`, you can create the timer with a reference to the event manager, and then use the timer's `start` and `stop` methods.",
        "ts": "1464107197.002562"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "no",
        "ts": "1464107270.002563"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The actual 'event wheel' type stuff could be implemented separately, as you have in custodian",
        "ts": "1464107283.002564"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "for tests the timers must be non-timers",
        "ts": "1464107286.002565"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "You could have the manager act as a timer factory if you wanted",
        "ts": "1464107321.002566"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "the event wheel must be in the event manager",
        "ts": "1464107326.002567"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I don't see why",
        "ts": "1464107332.002568"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "You have an event wheel in custodian, which seems to work fine, it just needs to not have a go routine",
        "ts": "1464107352.002569"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "because otherwise, how can the event manager decide whether to service a timer or an event?",
        "ts": "1464107353.002570"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Because it only gets the timer event if the event is not canceled",
        "ts": "1464107366.002571"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so the event manager internally uses something that implements a timer wheel?",
        "ts": "1464107398.002572"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Why do you need a timer wheel? Why not simply atomically get timer events, if you receiver a timer event, then it is valid.",
        "ts": "1464107427.002573"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "who produces the timer events?",
        "ts": "1464107440.002574"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The event timer, which has a reference to the event manager",
        "ts": "1464107452.002575"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(so that it can atomically deliver events)",
        "ts": "1464107470.002576"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and how is that event timer implemented?",
        "ts": "1464107471.002577"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "As a small state machine in a select statement",
        "ts": "1464107479.002578"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and where is it implemented?",
        "ts": "1464107505.002579"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "in the `eventTimer` struct",
        "ts": "1464107516.002580"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i mean the code",
        "ts": "1464107524.002581"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "of that state machine",
        "ts": "1464107528.002582"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The event timer would have a go routine which is created when it is constructed, that go routine would be responsible for servicing the events of 'start' 'stop' 'timer expired' and 'deliver event'.",
        "ts": "1464107607.002583"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The atomicity comes from the fact that the start, stop, and deliver events are all bound to the event manager thread",
        "ts": "1464107636.002584"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "how would that work in tests?",
        "ts": "1464107644.002585"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i.e. how do we make tests deterministic?",
        "ts": "1464107661.002586"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "use a different timer implementation?",
        "ts": "1464107665.002587"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, I think that would make most sense, have a timer factory of some sort so we can override the timer implementation in our unit tests",
        "ts": "1464107715.002588"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so then we might put that into the event manager",
        "ts": "1464107740.002589"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "We could",
        "ts": "1464107747.002590"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Since we would be supplying a different event manager for unit tests",
        "ts": "1464107775.002591"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "It would be a natural place to do it",
        "ts": "1464107781.002592"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes",
        "ts": "1464107787.002593"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i don't see any benefit of using a go routine per timer, vs a timer wheel for all timers",
        "ts": "1464107799.002594"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The event manager in the non-unit test implementation becomes much simpler, and it allows us to in the near term retain the majority of our existing code",
        "ts": "1464107914.002595"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I don't see any particular problem with a go routine per timer",
        "ts": "1464107925.002596"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "well, it needs more resources.",
        "ts": "1464107952.002597"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The overhead of a go routine is pretty minimal, especially since we're talking about two or three of them",
        "ts": "1464107975.002598"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "well, custodian",
        "ts": "1464107984.002599"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "potentially hundreds",
        "ts": "1464107988.002600"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "No, not at all",
        "ts": "1464107993.002601"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "the advantage of a timer wheel is that event order is determined on enqueue",
        "ts": "1464108013.002602"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "For custodian, who already implements a timer wheel, he would simply keep his implementation, and use a single timer to trigger processing",
        "ts": "1464108015.002603"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and events don't race delivery",
        "ts": "1464108022.002604"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "For custodian, that works because all of your timeouts are the same",
        "ts": "1464108030.002605"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Or rather, your queuing logic is simple because of that",
        "ts": "1464108049.002606"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes",
        "ts": "1464108051.002607"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "basically i'm proposing a completely deterministic system",
        "ts": "1464108071.002608"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "with go routines, you get events delivered non-deterministically",
        "ts": "1464108099.002609"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "You're proposing a completely deterministic set of timers, we still get non-determinism on timer vs. msg for instance",
        "ts": "1464108146.002610"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes we do",
        "ts": "1464108152.002611"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but that we can't control",
        "ts": "1464108160.002612"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i think implementing the timers with goroutines is fine for now, because it reduces the amount of change",
        "ts": "1464108182.002613"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but eventually, i'd like to replace the timers with a deterministic timer wheel",
        "ts": "1464108213.002614"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I think there's nothing prohibiting that, and in fact, I think we'd basically just move the select statement out of the timer and into the event manager",
        "ts": "1464108245.002615"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(with a few minor modifications of course)",
        "ts": "1464108260.002616"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yea",
        "ts": "1464108265.002617"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "okay, i gotta take off",
        "ts": "1464108286.002618"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Alright, thanks for the discussion",
        "ts": "1464108298.002619"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "if you push intermediate code to your repo, i'll be able to review it at some point",
        "ts": "1464108341.002620"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I'm really trying to keep these changesets small so that we can meaningfully do them as PRs",
        "ts": "1464108413.002621"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yea",
        "ts": "1464108419.002622"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Hopefully I can push it as a PR for public review\/comment (so that we don't have to do the private repo review)",
        "edited": {
            "user": "U0XPR4NP4",
            "ts": "1464108445.000000"
        },
        "ts": "1464108424.002623"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "<@U0XR6J961>, <@U0XPR4NP4> : haven\u2019t paid attention\u2026 saw go routines and timers.. will this help stabilize tests so timing is not an issue ?",
        "ts": "1464108442.002624"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes",
        "ts": "1464108467.002626"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "ok",
        "ts": "1464108469.002627"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "thanks",
        "ts": "1464108472.002628"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "once tests don't have goroutines, all will be better",
        "ts": "1464108478.002629"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0ULK2JPP>: Yes, the biggest source of instability in our tests is racing go routines, we're trying to kill them off",
        "ts": "1464108478.002630"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "ok",
        "ts": "1464108484.002631"
    }
]