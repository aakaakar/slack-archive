[
    {
        "user": "U1MA81VBK",
        "text": "<@U1MA81VBK|g_alexander> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1474967619.001064"
    },
    {
        "user": "U2FR6FUJV",
        "text": "<@U2FR6FUJV|niubwang> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1474980846.001065"
    },
    {
        "type": "message",
        "user": "U2FR6FUJV",
        "text": "hi guys,  when i add a new validator peer (using PBFT),  the new peer can't sync  blocks from the others,  who can help me?",
        "ts": "1474980863.001066"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "hi",
        "ts": "1474980899.001067"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "you cannot do that dynamically",
        "ts": "1474980912.001068"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "you will have to shut down the whole network, configure all for the new number of validators, then restart",
        "ts": "1474980954.001069"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "then use the network as usual, and the new peer should sync up eventually",
        "ts": "1474980978.001070"
    },
    {
        "type": "message",
        "user": "U2FR6FUJV",
        "text": "<@U0XR6J961>  hi, is this by design?  i want to dynamically add  new peers with not shut down the whole network",
        "ts": "1474981419.001071"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "not implemented at the moment",
        "ts": "1474981475.001072"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "will come in 1.0",
        "ts": "1474981477.001073"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i think",
        "ts": "1474981479.001074"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "eventually in 1.0 - yes",
        "ts": "1474981489.001075"
    },
    {
        "type": "message",
        "user": "U2FR6FUJV",
        "text": "i want use the fabric for business, is that mean now i can't use this? when the 1.0  will come?",
        "ts": "1474981651.001076"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "you can, you just can't change the set of validators without stopping the network for a moment",
        "ts": "1474981962.001077"
    },
    {
        "type": "message",
        "user": "U2FR6FUJV",
        "text": "<@U0XR6J961>  for example, if i run 5 validators, then one of them is shut dowm for a moment, if this peer is restarted,  can it sync blocks form others?",
        "ts": "1474982354.001078"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "if it is just shut down and restarted, yes",
        "ts": "1474982389.001079"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but 5 validators is usually not as good as 4",
        "ts": "1474982412.001080"
    },
    {
        "type": "message",
        "user": "U2FR6FUJV",
        "text": "<@U0XR6J961>  what i want to do, is i want to run some validators in my server , and i want to the other guest users to run some validators, so they can get the block data <http:\/\/too.as|too.as> you mean, now i can't add validators for  new guest users",
        "ts": "1474983076.001081"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i think you want non-validator peers",
        "ts": "1474983165.001082"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "which never really worked, i think",
        "ts": "1474983172.001083"
    },
    {
        "type": "message",
        "user": "U2FR6FUJV",
        "text": "i think the non-validator peers now can't sync blocks too",
        "ts": "1474983275.001084"
    },
    {
        "type": "message",
        "user": "U2FR6FUJV",
        "text": "i want the guest user can save the block data locally",
        "ts": "1474983599.001085"
    },
    {
        "user": "U1KDHJT6H",
        "text": "<@U1KDHJT6H|claytonsims> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1475003516.001086"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0ULK2JPP> <@U1KFCPFQA> I've created an epic around supporting embedding orderer configuration in the raw ledger <https:\/\/jira.hyperledger.org\/browse\/FAB-495> if you would like to take a look",
        "ts": "1475010003.001087"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U1BC5A0F9> You might also have an opinion",
        "ts": "1475010152.001088"
    },
    {
        "user": "U1BC5A0F9",
        "inviter": "U0XPR4NP4",
        "text": "<@U1BC5A0F9|elli> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1475010164.001089"
    },
    {
        "type": "message",
        "user": "U1KFCPFQA",
        "text": "Jason, these would be transactions on the \u2018main\u2019 ledger right?  As opposed to a side ledger for orderer config",
        "ts": "1475010415.001090"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Correct",
        "ts": "1475010420.001091"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "There could be a side ledger to help orchestrate for an ordering network, but this needs to be per chain I believe",
        "ts": "1475010441.001092"
    },
    {
        "type": "message",
        "user": "U1KFCPFQA",
        "text": "and i assume ordering service would need to read the ledger state right",
        "ts": "1475010450.001093"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Well, that is the question",
        "ts": "1475010651.001094"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "You'll notice in FAB-499 I was intentionally non-specific",
        "ts": "1475010669.001095"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "If we pull in the ledger, and do real MVCC parsing, then we'll need to bring some amount of stuff along",
        "edited": {
            "user": "U0XPR4NP4",
            "ts": "1475010701.000000"
        },
        "ts": "1475010689.001096"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XR6J961> I'd especially like your input in regards to FAB-499.  If the orderer is going to need to understand how to apply a fabric type transaction (or least pieces of it), what is your opinion of simply pulling in the peer support for it, vs trying to build something lighter and more ad-hoc?  Basically, the idea would be that the ordering service would be a stripped down version of the 0.5 framework (with determinism), where the only transaction type which actually executes is a reconfiguration transaction, but we re-use the peer code for doing validation of endorsement, updating the database, MVCC etc.  This seems a bit heavy handed and maybe more than we really want the ordering service to do.  On the other hand, it seems like it could really lend itself well to code re-use, so that we are not solving the same problems twice.",
        "ts": "1475010798.001098"
    },
    {
        "type": "message",
        "user": "U1KFCPFQA",
        "text": "With a naive approach we\u2019d push the entire state database to raw ledger side\u2026 we hadn\u2019t planned on that previously, and i don\u2019t think you want the entire state database actually. Maybe a subledger with state database for orderer config that everybody shares?  And for the main system ledger, ordering service doesn\u2019t keep the state database?",
        "ts": "1475010853.001099"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XQ35CDD> <@U0UGH3X7X> <@U1KDAMDJ7> Your opinions also welcome",
        "ts": "1475010857.001100"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I would say absolutely no to pushing the entire state database to the raw ledger side",
        "ts": "1475010882.001101"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "If by that you mean to the orderer",
        "ts": "1475010895.001102"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "We would just want the ledger for the orderer configuration system chaincode",
        "ts": "1475010915.001103"
    },
    {
        "type": "message",
        "user": "U1KFCPFQA",
        "text": "right, that would be the naive approach, which i agree we wouldn\u2019t want",
        "ts": "1475010916.001104"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Which seems easy enough if we only 'execute' the orderer configuration transactions",
        "ts": "1475010943.001105"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "<@U0XPR4NP4>  -  while I think on one side you are saying reuse some \"fabric\" mechanisms for the PBFT ordering service in order to provide the ability to update the \"config\" (membership, etc) of the PBFT ordering service, it also sounds like you are proposing a very tight coupling of the ordering service and the fabric",
        "ts": "1475011318.001106"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "which is not what we want IMHO.  But hey - what do I know?",
        "ts": "1475011346.001107"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "To me, I should be able to use any ordering service without consuming it from the fabric",
        "ts": "1475011400.001108"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0PB67X4K> The fabric and the ordering service need to agree on the orderer configuration.  And, in order to synchronize it with the chain, it most likely needs to be embedded in the chain",
        "ts": "1475011414.001109"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "My initial thought was, embed some binary blob, which we describe the format of, and done",
        "ts": "1475011443.001110"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "But as we talked about it, things like \"Well, we'll need to validate that the right signatures are here\" and so forth, it sounded a lot like endorsement",
        "ts": "1475011468.001111"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "So I am not saying that an implementation of the ordering service could not choose to use pieces of the fabric, but what I am saying is that I should be able to use that ordering service from something other than the fabric",
        "ts": "1475011540.001112"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Ah, yes, absolutely.  I am not suggesting you could not do that",
        "ts": "1475011565.001113"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Maybe, the fabric transaction format is too complicated to reasonably expect a non-fabric application to support",
        "ts": "1475011589.001114"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "As I was trying to come up with a way of generating this fabric-type-transaction, I realized it was going to be quite a pain, which why I started thinking about pulling the common code bits in",
        "ts": "1475011665.001115"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "But ultimately, the ordering service takes in blobs, and spits out batches\/blocks of blobs",
        "ts": "1475011700.001116"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Just in the case that that blob happened to be the special configuration transaction type blob, it would do some other stuff",
        "ts": "1475011718.001117"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(I'm also a little concerned with the overhead of inspecting every blob to see if it's a special type.  However, since we're already going to have to be hashing and checking signatures, it seems like not a lot of additional overhead)",
        "ts": "1475011826.001118"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "well you could avoid that by having a special \"channel\" for config transactions",
        "ts": "1475011860.001119"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "that's what lots of messaging servers do",
        "ts": "1475011871.001120"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "they have \"system\" topics and queues",
        "ts": "1475011880.001121"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Right",
        "ts": "1475011885.001122"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The question is synchronizing that configuration to the other chains",
        "ts": "1475011901.001123"
    },
    {
        "user": "U1TMQDYKE",
        "text": "<@U1TMQDYKE|wil.pannell> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1475011911.001124"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "How do you know that at block 30 that you should be looking for a different set of signatures?",
        "ts": "1475011921.001125"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "You could embed which block the configuration change applies to in the special system chain, but how do you know you have an up to date enough copy of the system chain?",
        "ts": "1475011959.001126"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Having it within the same message stream solves a lot of problems, though I admit, it creates some too.  I'm certainly open to other approaches.",
        "ts": "1475012011.001127"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "and doesn't the problem become worse with multiple channels?   we would be guaranteeing order per channel but not total order across channels",
        "ts": "1475012020.001128"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, every channel would need to get a 'reconfiguration transaction' when the configuration changed",
        "ts": "1475012055.001129"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I would expect for reconfiguration events to be pretty rare, but it's a concern",
        "ts": "1475012082.001130"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "so for example, if for PBFT we decide that you need to receive f+1 of the same message before \"delivering\" to the raw ledger and then at some point you increase the number of ordering nodes, how do you handle that?",
        "ts": "1475012093.001131"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "okay - so you insert a tx in the stream of every channel?",
        "ts": "1475012129.001132"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Right",
        "ts": "1475012133.001133"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I don't see any way around that, especially if you decide you want to scale your ordering service.  You might have a single service hosting 10k channels, and you decide you want to move half of the channels to a new set of nodes.  Not sure how else you do it.",
        "ts": "1475012202.001134"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "and I guess it does not have to be \"atomic\" across all channels - it just has to make it into all channels",
        "ts": "1475012205.001135"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Right",
        "ts": "1475012210.001136"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "but this makes the consumer side logic a bit complex in some cases - for example I can listen for multiple channels on the same physical connection, but now my handlers for each channel might have a different policy for a short period of time.    On the other hand, from the consuming \/ committing peer, they really should not be aware of any of this if we handle it in the \"ordering service client\" piece",
        "ts": "1475012356.001137"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Right.  And, I would argue, absolutely your ordering configuration might deliberately be different for different channels.",
        "ts": "1475012391.001138"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "and I guess these config transactions would be a block with a single tran?",
        "ts": "1475012397.001139"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "You could implement them that way, though I see no immediate harm in including them in a batch with other trans",
        "ts": "1475012426.001140"
    },
    {
        "type": "message",
        "user": "U0PB67X4K",
        "text": "true enough.  although kind of nice to treat them a bit special",
        "ts": "1475012470.001141"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, making them easy to spot is a plus",
        "ts": "1475012492.001142"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "At the end of the day, the fabric and the ordering service both need to have the same view of \"who's ordering\" for the same blocks.  How we synchronize this data is up in the air to me.  I think it make sense to send it across as part of the chain.  It looks a whole lot like a fabric transaction, because we will want to ultimately validate it with signatures etc., but really, the fabric transaction format is probably more complex than necessary for it.  I'd also be open to making a new transaction type (the data structure already supports this) which is much simpler just for config.  But, then we have to re-invent some stuff which is already handled by the existing transaction.  I'd really love to be persuaded one way or the other.",
        "ts": "1475012650.001143"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "In discussions last Thursday I think <@U0UKTPMG8> was a big proponent of re-using the fabric transaction, maybe he wants to voice his opinion here too.",
        "ts": "1475012737.001144"
    },
    {
        "type": "message",
        "user": "U0UKTPMG8",
        "text": "<@U0XPR4NP4> <@U0PB67X4K> yes, I think we can use transaction now as I would in the future like the option to have the consensus service request a change through endorsement of the associated channel",
        "ts": "1475014322.001145"
    }
]