[
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "<@U0Y14MWA2> I had missed this message, sorry. Yes, this is a good observation. If you no longer have a majority quorum in your ZK ensemble and, say, the partition leader crashes, you'd be in trouble.",
        "attachments": [
            {
                "fallback": "[September 30th, 2016 5:26 AM] vukolic: perhaps not a huge problem but just mentioning",
                "ts": "1475227587.001374",
                "author_subname": "vukolic",
                "channel_id": "C0Z4NBUN6",
                "channel_name": "fabric-consensus-dev",
                "is_msg_unfurl": true,
                "text": "perhaps not a huge problem but just mentioning",
                "author_name": "Marko Vukolic",
                "author_link": "https:\/\/hyperledgerproject.slack.com\/team\/vukolic",
                "author_icon": "https:\/\/secure.gravatar.com\/avatar\/a52edd136bbd07ca069b9393ac60f675.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2F66f9%2Fimg%2Favatars%2Fava_0006-48.png",
                "mrkdwn_in": [
                    "text"
                ],
                "color": "D0D0D0",
                "from_url": "https:\/\/hyperledgerproject.slack.com\/archives\/fabric-consensus-dev\/p1475227587001374",
                "is_share": true,
                "footer": "Posted in #fabric-consensus-dev"
            }
        ],
        "ts": "1475480988.001410"
    },
    {
        "user": "U1WTREFUK",
        "text": "<@U1WTREFUK|ckeyer> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1475481232.001411"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Given that we're asked to post updates here --",
        "ts": "1475486225.001412"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "I finished the work on the kafka-orderer this past Friday <https:\/\/github.com\/kchristidis\/fabric\/tree\/kafka-orderer-complete\/orderer> (<https:\/\/jira.hyperledger.org\/browse\/FAB-32?focusedCommentId=19084> - will post the changeset once the Vagrant image gets upgraded to Go 1.7)",
        "edited": {
            "user": "U0XQ35CDD",
            "ts": "1475486891.000000"
        },
        "ts": "1475486246.001413"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Was also asked how Kafka deals with reconfiguration, I posted about this here: <https:\/\/jira.hyperledger.org\/browse\/FAB-496?focusedCommentId=19092>",
        "ts": "1475486259.001415"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Up next: review the SBFT changeset",
        "ts": "1475486265.001416"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yey",
        "ts": "1475486318.001417"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "\\o\/ i get a review",
        "ts": "1475486330.001418"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Sorry, yeah, I was planning to get to it last week but I bumped into some misconfiguration issues with the Kafka\/ZooKeeper images (that only manifested themselves after I tried to test via Docker Compose in Vagrant)",
        "ts": "1475486594.001419"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "no worries",
        "ts": "1475487928.001422"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i'm trying to figure out what to do with backlog messages and reconnect events",
        "ts": "1475488044.001423"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ah suddenly it seems to make sense",
        "ts": "1475488063.001424"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "<@U1BC5A0F9>: right now i store a list of blobs to represent the signatures on a block",
        "ts": "1475493245.001425"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "<@U1BC5A0F9>: do i also have to store some kind of identification for the signature, so that you can test it against a key?",
        "ts": "1475493268.001426"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "how is this done usually?",
        "ts": "1475493274.001427"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "Hi, <@U0XR6J961> : yes, this is correct; one would need to include the certs (or references to the certs) of the users who are signing.",
        "ts": "1475493562.001428"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "users\/nodes.",
        "ts": "1475493566.001429"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "the consenter, in this case",
        "ts": "1475493874.001430"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "thanks, somehow i missed that",
        "ts": "1475493880.001431"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "what is a customary way of doing this?",
        "ts": "1475493889.001432"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "attach the cert or the cert fingerprint?",
        "ts": "1475493902.001433"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "do you prefer protobuf or asn1?",
        "ts": "1475493923.001434"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "So it depends. Cert fingerprint could suffice if every peer who is supposed to evaluate the signatures is already in posession of the Certs.",
        "ts": "1475498059.001435"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ah i see",
        "ts": "1475498083.001436"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "If e.g., certs of valid orderers are announced through the blockchain (since i am guessing you refer to orderer signatures) , then a fingerprint would suffice.",
        "ts": "1475498096.001437"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes",
        "ts": "1475498104.001438"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yea they have to be announced",
        "ts": "1475498113.001439"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "re: protobuf or asn1 i would invite <@U0ZR63HLK>  to the discussion.",
        "edited": {
            "user": "U1BC5A0F9",
            "ts": "1475498237.000000"
        },
        "ts": "1475498216.001440"
    },
    {
        "user": "U0ZR63HLK",
        "inviter": "U1BC5A0F9",
        "text": "<@U0ZR63HLK|adc> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1475498241.001442"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "I would say ASN1 but it makes sense that we are consistent with the rest of signatures produced.",
        "ts": "1475498322.001443"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yea",
        "ts": "1475498332.001444"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "probably all structures that should be stored would be better in ASN1",
        "ts": "1475498346.001445"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but not my decision",
        "ts": "1475498360.001446"
    },
    {
        "user": "U2JK6JCTZ",
        "text": "<@U2JK6JCTZ|alankhlim> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1475500476.001447"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "<@U0XPR4NP4>: so that's the difference between batch and block: batch refers to replica ids, block contains replica certificates\/fingerprints",
        "ts": "1475502424.001448"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XR6J961> I think that depends on which 'batch' you're referring to, the batches emitted from the ordering service are blocks (only called batches to differentiate them from the validated blocks), it could be we want additional data around a PBFT batch, though if we could avoid additional fields reusing the block structure seems preferable",
        "ts": "1475504425.001449"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "FYI, I tagged you on this, <https:\/\/gerrit.hyperledger.org\/r\/#\/c\/1361\/>  but have not seen any feedback from you on it.  It seems many people do not want to use a Merkle tree for the block contents hash, which is fine by me, but I know you picked Merkle tree for your impl, so wasn't sure if you had some other reason for it",
        "ts": "1475504524.001450"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "posting my updates as Kostas is doing earlier today ...  added default endorser and validator system chaincodes to feature\/convergence ... these don't do much right now except to help get the end-to-end skeleton going ... we will be adding more capabilities as we get v1 going  <https:\/\/gerrit.hyperledger.org\/r\/#\/c\/1367\/>",
        "ts": "1475504785.001451"
    },
    {
        "type": "message",
        "user": "U0XV1HDL3",
        "text": "<@U0XR6J961>, @mvu, <@U0UGH3X7X>, <@U0XQ35CDD>, everyone: Have a look at the message formats posted here -- <https:\/\/hyperledgerproject.slack.com\/files\/adc\/F2JKXGXEU\/protobufmessagesandflow.pdf>",
        "ts": "1475507278.001452"
    },
    {
        "type": "message",
        "subtype": "file_mention",
        "text": "<@U0XV1HDL3|cca> mentioned a file: <https:\/\/hyperledgerproject.slack.com\/files\/adc\/F2JKXGXEU\/protobufmessagesandflow.pdf|ProtobufMessagesAndFlow.pdf>.",
        "file": {
            "id": "F2JKXGXEU",
            "created": 1475506254,
            "timestamp": 1475506254,
            "name": "ProtobufMessagesAndFlow.pdf",
            "title": "ProtobufMessagesAndFlow.pdf",
            "mimetype": "application\/pdf",
            "filetype": "pdf",
            "pretty_type": "PDF",
            "user": "U0ZR63HLK",
            "editable": false,
            "size": 824792,
            "mode": "hosted",
            "is_external": false,
            "external_type": "",
            "is_public": true,
            "public_url_shared": false,
            "display_as_bot": false,
            "username": "",
            "url_private": "https:\/\/files.slack.com\/files-pri\/T0J024XGA-F2JKXGXEU\/protobufmessagesandflow.pdf?t=xoxe-18002167554-139099126023-137701436192-e599afc92e",
            "url_private_download": "https:\/\/files.slack.com\/files-pri\/T0J024XGA-F2JKXGXEU\/download\/protobufmessagesandflow.pdf?t=xoxe-18002167554-139099126023-137701436192-e599afc92e",
            "permalink": "https:\/\/hyperledgerproject.slack.com\/files\/adc\/F2JKXGXEU\/protobufmessagesandflow.pdf",
            "permalink_public": "https:\/\/slack-files.com\/T0J024XGA-F2JKXGXEU-66a1d1cac6",
            "channels": [
                "C2GE7GXM1"
            ],
            "groups": [],
            "ims": [],
            "comments_count": 1,
            "initial_comment": {
                "id": "Fc2JJF8RPV",
                "created": 1475506254,
                "timestamp": 1475506254,
                "user": "U0ZR63HLK",
                "is_intro": true,
                "comment": "Hi All, this file contains the protobuf messages and the relative flow with the security checks to put in place. This a joint effort with <@U1BC5A0F9> and <@U26T99AQ4>.",
                "channel": ""
            },
            "reactions": [
                {
                    "name": "+1",
                    "users": [
                        "U1GN670VD"
                    ],
                    "count": 1
                }
            ]
        },
        "user": "U0XV1HDL3",
        "ts": "1475507278.001453"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "<@U0XV1HDL3> `@mvu` did not resolve to a slack user",
        "ts": "1475508582.001454"
    },
    {
        "type": "message",
        "user": "U0XV1HDL3",
        "text": "<@U0Y14MWA2>",
        "ts": "1475509842.001455"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XV1HDL3> I've been looking at those as they have been in development, <@U1BC5A0F9> I do not see a date, is that newer than what I have last seen?",
        "ts": "1475511046.001456"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "Hi, <@U0Y14MWA2>: it should be, as we just completed it today :slightly_smiling_face:",
        "ts": "1475512622.001457"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U1BC5A0F9> is there a place we can provide feedback on them?",
        "ts": "1475512694.001458"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "There should be a JIRA issue IMO",
        "ts": "1475512737.001459"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "fabric-crypo channel?",
        "ts": "1475513034.001460"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "crypto*",
        "ts": "1475513042.001461"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "there is also a jira item indeed, but i think the fabric-crypto channel is easier if you want more ppl seeing it.",
        "ts": "1475513099.001462"
    },
    {
        "user": "U1VG8LNP3",
        "text": "<@U1VG8LNP3|yaoguo> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1475513535.001463"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "elli: in short, what validation steps does the orderer have to perform?",
        "ts": "1475513855.001464"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and over what is the signature",
        "ts": "1475513880.001465"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "How would you define short? :smile:",
        "ts": "1475513932.001466"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "which fields have to be validated",
        "ts": "1475513953.001467"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "more than just check the signature?",
        "ts": "1475513963.001468"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "does this signature field opaquely contain the signing identity (cert)?",
        "ts": "1475513991.001469"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XR6J961> my very rough understanding from <@U1BC5A0F9> is that that signature field is the signature of the identity contained in the proposalheader, assuming all proposal headers have the same identity, and potentially some more complicated scheme if they differ.  I hope I am wrong, because that seems very expensive to check and complicated to me",
        "ts": "1475514469.001470"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "In some ways, I actually think that what we need is a higher level crypto primitive message, something which embeds an identity and signature, as well as whatever things are required to prevent replay (timestamp\/nonce\/ttl, whatever), a type, and a payload",
        "ts": "1475514577.001471"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "So do you mean what is checked by VSCC (assuming the default one)",
        "ts": "1475514604.001472"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "?",
        "ts": "1475514608.001473"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "For the orderer, which remember does not have a VSCC",
        "ts": "1475514626.001474"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "ok, i see",
        "ts": "1475514647.001475"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The orderer is going to get a message from a client, presumably today that is a transaction, and the orderer needs to be able to tell \"is this actually from a client who is allowed to submit messages\"",
        "ts": "1475514656.001476"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "and the purpose of the orderer to check signature is which exactly?",
        "ts": "1475514667.001477"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "is it DoS related?",
        "ts": "1475514673.001478"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Because each orderer can validate the connections from clients via TLS easily enough",
        "ts": "1475514681.001479"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "However, because we allow for byzantine orderers, one orderer (say the primary) might lie and say \"Yes, this transaction came from a client who's TLS cert is authorized\" but instead make up transactions",
        "edited": {
            "user": "U0XPR4NP4",
            "ts": "1475514761.000000"
        },
        "ts": "1475514713.001480"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Of course they would be filtered out at the peer side, but the byzantine primary could essentially stop network progress by making up nonsense",
        "ts": "1475514736.001481"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "aha",
        "ts": "1475514784.001483"
    },
    {
        "type": "message",
        "user": "U0XV1HDL3",
        "text": "<@U0XPR4NP4>: that risk of a faulty primary could exist, but for the usecases we look at mostly (consortium), it seems irrelevant. that is, building in a defense against it that is always executed slows down unnecessarily",
        "ts": "1475514795.001484"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "but then one could add in the transaction message the certificate of the client, that would enable the orderer to do the check easily",
        "edited": {
            "user": "U1BC5A0F9",
            "ts": "1475514812.000000"
        },
        "ts": "1475514800.001485"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "but VSCC would need to do the comprehensive checks",
        "ts": "1475514822.001487"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "that we discuss in the charts",
        "ts": "1475514827.001488"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XV1HDL3> This was a concern from <@U0Y14MWA2> I just replied to a note where he said that we need to do this check",
        "ts": "1475514850.001489"
    },
    {
        "type": "message",
        "user": "U0XV1HDL3",
        "text": "... putting all of this together gives an overly complex result, it seems to me.",
        "ts": "1475514878.001490"
    },
    {
        "type": "message",
        "user": "U0XV1HDL3",
        "text": "his note may not have considered the existence of TLS certs and the closed group",
        "ts": "1475514894.001491"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XV1HDL3> Another reason I thought having the messages be signed is, imagine a byzantine client of the ordering service injects malformed non-sense, but has a validated TLS cert",
        "ts": "1475514983.001492"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Orderers could check tcert which prevents primary to issue an arbitrary bogus request",
        "ts": "1475514988.001493"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Hovewer tcerts do not prevent primary from replaying old legitimate requests",
        "ts": "1475515024.001494"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "If we had clients sign with ecerts this is a non issue",
        "ts": "1475515050.001495"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "But tcerts inherently prevent tra cking clients",
        "ts": "1475515067.001496"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "And we cannot store all past requests to prevent Replay",
        "ts": "1475515095.001497"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0Y14MWA2> <@U0XV1HDL3> I can see how the primary could make the chain increase in size rapidly, but even with replay or forgery, won't it be voted out from primary if it is not including the pending requests of the other backups?",
        "ts": "1475515107.001498"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Yes but it could do that",
        "ts": "1475515200.001499"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Plus replay",
        "ts": "1475515208.001500"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Preventing replay with tcerts is  difficult",
        "ts": "1475515261.001501"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "We may reason about time",
        "ts": "1475515290.001502"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Either logical or \"real\"",
        "ts": "1475515312.001503"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "That may help...",
        "ts": "1475515321.001504"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "There is the notion of time embedded within the proposalheader I believe",
        "ts": "1475515344.001505"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U1BC5A0F9> What is the purpose of having multiple proposals embedded within one transaction? What happens if some of the proposals are valid and some are not?",
        "ts": "1475515443.001506"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i don't quite care about this transaction format",
        "ts": "1475515465.001507"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i think we should just add signature field in the atomic broadcast `Broadcast` ingress call",
        "ts": "1475515500.001508"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "field or argument",
        "ts": "1475515507.001509"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "That does not handle replay",
        "ts": "1475515520.001510"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "the orderer should not know anything about what it is ordering",
        "ts": "1475515521.001511"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "then add a sequence number",
        "ts": "1475515550.001512"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "If we add some time notion",
        "ts": "1475515557.001513"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Like a sequence number",
        "ts": "1475515564.001514"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "That helps",
        "ts": "1475515568.001515"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Sequence number per client?",
        "ts": "1475515569.001516"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "No",
        "ts": "1475515574.001517"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes",
        "ts": "1475515574.001518"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "no?",
        "ts": "1475515578.001519"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "With tcerts that does not work",
        "ts": "1475515585.001520"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Woth ecerts that works",
        "ts": "1475515593.001521"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ah",
        "ts": "1475515593.001522"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "why do we need that whole tcert business?",
        "ts": "1475515605.001523"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Anonymity...",
        "ts": "1475515613.001524"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Unlinkability",
        "ts": "1475515620.001525"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "So a client will need to connect to the ordering service... using the t-cert?",
        "ts": "1475515622.001526"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "N stuff",
        "ts": "1475515624.001527"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "And will need to disconnect and reconnect between to attempt to prevent linking?",
        "ts": "1475515643.001528"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "No clue",
        "ts": "1475515660.001529"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Previously",
        "ts": "1475515663.001530"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yea, that's all silly",
        "ts": "1475515665.001531"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "When we had a submitting peer",
        "ts": "1475515673.001532"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "This was less pronounced",
        "ts": "1475515679.001533"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "should the peer also connect via TOR?",
        "ts": "1475515696.001534"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "On a dial up",
        "ts": "1475515705.001535"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "If you don't want a byzantine orderer to associate all the transactions from a single address with a single identity... probably",
        "ts": "1475515720.001536"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "For the reason you listed below (we'd still need to keep a giant list of all past TXs), it would still be an issue right?",
        "attachments": [
            {
                "fallback": "[October 3rd, 2016 1:17 PM] vukolic: If we had clients sign with ecerts this is a non issue",
                "ts": "1475515050.001495",
                "author_subname": "vukolic",
                "channel_id": "C0Z4NBUN6",
                "channel_name": "fabric-consensus-dev",
                "is_msg_unfurl": true,
                "text": "If we had clients sign with ecerts this is a non issue",
                "author_name": "Marko Vukolic",
                "author_link": "https:\/\/hyperledgerproject.slack.com\/team\/vukolic",
                "author_icon": "https:\/\/secure.gravatar.com\/avatar\/a52edd136bbd07ca069b9393ac60f675.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2F66f9%2Fimg%2Favatars%2Fava_0006-48.png",
                "mrkdwn_in": [
                    "text"
                ],
                "color": "D0D0D0",
                "from_url": "https:\/\/hyperledgerproject.slack.com\/archives\/fabric-consensus-dev\/p1475515050001495",
                "is_share": true,
                "footer": "Posted in #fabric-consensus-dev"
            }
        ],
        "ts": "1475515732.001537"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "From public phone booth",
        "ts": "1475515734.001538"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "1 per client <@U0XQ35CDD>",
        "ts": "1475515756.001539"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Not that huge",
        "ts": "1475515764.001540"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "In real life",
        "ts": "1475515772.001541"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, this is what the original Castro paper suggests if I recall",
        "ts": "1475515790.001542"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Yes this is the classical approach",
        "ts": "1475515813.001543"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Then do we require that the TLS cert for the connection and the TLS signature for the message match?",
        "ts": "1475515849.001544"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "not for clients at the moment",
        "ts": "1475515961.001545"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "for replicas yes",
        "ts": "1475515966.001546"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "we can still do replay protection for tcerts",
        "ts": "1475516024.001547"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "we discard the state when the tcert expires",
        "ts": "1475516032.001548"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "or we require a client to submit a new request directly to 2f+1 correct replicas (i.e. send it to 3f+1)",
        "ts": "1475516084.001549"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "(<@U0Y14MWA2>: FWIW, I think we're dealing with the same complexity in any case. Whether you deal with 100 tcert'd TXs (that you can place in 10 buckets) versus 10 clients with 10 ecert'd TXs each, it still the same accessing cost, if you do the mapping and splitting to buckets right.)",
        "attachments": [
            {
                "fallback": "[October 3rd, 2016 1:29 PM] vukolic: Not that huge",
                "ts": "1475515764.001540",
                "author_subname": "vukolic",
                "channel_id": "C0Z4NBUN6",
                "channel_name": "fabric-consensus-dev",
                "is_msg_unfurl": true,
                "text": "Not that huge",
                "author_name": "Marko Vukolic",
                "author_link": "https:\/\/hyperledgerproject.slack.com\/team\/vukolic",
                "author_icon": "https:\/\/secure.gravatar.com\/avatar\/a52edd136bbd07ca069b9393ac60f675.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2F66f9%2Fimg%2Favatars%2Fava_0006-48.png",
                "mrkdwn_in": [
                    "text"
                ],
                "color": "D0D0D0",
                "from_url": "https:\/\/hyperledgerproject.slack.com\/archives\/fabric-consensus-dev\/p1475515764001540",
                "is_share": true,
                "footer": "Posted in #fabric-consensus-dev"
            }
        ],
        "ts": "1475516091.001550"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and we occasionally inform the primary which request (hashes) we have outstanding",
        "ts": "1475516148.001551"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XR6J961> I really like the idea of the orderer being totally agnostic to the message contents, but am struggling with how this can mesh with reconfiguration.  If the orderer configuration must be on the chain, how can the orderer treat all messages as opaque bytes?",
        "ts": "1475516159.001552"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "that's the only message type it knows",
        "ts": "1475516207.001553"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "So the orderer does inspect every message, and check whether it's a reconfiguration one or not (and if it's a reconfiguration one, it might choose to discard it if it is not valid)",
        "ts": "1475516239.001554"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes",
        "ts": "1475516265.001555"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "That's how I thought it would work as well.",
        "ts": "1475516269.001556"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Okay, that was what I was thinking, but to me that is not 'totally opaque'",
        "ts": "1475516316.001557"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "It is not. The only other way is a side-channel specific for reconfiguration, but we don't want this for the reasons we have mentioned several times.",
        "ts": "1475516362.001558"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Because the peer needs to understand the reconfiguration as well, would you agree it makes sense to try to re-use the fabric transaction format for the reconfiguration message?",
        "ts": "1475516366.001559"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i disagree",
        "ts": "1475516481.001560"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "that format is way complicated",
        "ts": "1475516487.001561"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "This is why I would like to see the format simplified",
        "ts": "1475516542.001562"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "also the protobufs don't look like they've been created with signing in mind",
        "ts": "1475516573.001563"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The problem I see, is that the peer wants to define all of its ledger interfaces to expect something of type fabric transaction for every slice of bytes in the block",
        "ts": "1475516582.001564"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i'd prefer stable pieces of data (i.e. what gets stored, not rpc messages) to be in ASN1",
        "ts": "1475516610.001565"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Which I think seems perfectly reasonable, I think it's odd to say \"Everything will be of type fabric transaction, except for those that are of type orderer transaction\"",
        "ts": "1475516618.001566"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "What exactly prevents the peer from doing a type switch on the received messages?",
        "ts": "1475516624.001567"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Receive bytes, unpack, type switch.",
        "ts": "1475516636.001568"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "You could, but that switch then propagates throughout the rest of the ledger interfaces",
        "ts": "1475516671.001569"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "so AB block payloads need to contain a type field",
        "ts": "1475516698.001570"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "At the end of the day, they are both transactions, and actually very similar, they both require a proposed change, and a set of signatures from those who are allowed to permit the change",
        "ts": "1475516708.001571"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "which probably makes sense",
        "ts": "1475516709.001572"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "because it allows you to multiplex different applications over the blockchain",
        "ts": "1475516724.001573"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "well, i'm out",
        "ts": "1475516742.001574"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Block payloads need to contain a type field?",
        "ts": "1475516748.001575"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "IE, the block gets a type? Or each of the block contents get a type?",
        "ts": "1475516762.001576"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "A block-level type is\/seems less expensive. If the orderer creates a reconfig message, it ships it on its own block whose type is set to \"config\", otherwise it batches a bunch of TXs and sets the type of the block to \"tran\".",
        "ts": "1475516915.001577"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Interesting",
        "ts": "1475516935.001578"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "This is also in-line with Gari's suggestion to keep things simple and devote an entire block\/batch to the reconfiguration.",
        "ts": "1475516941.001579"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "To me, it seems far more natural to have a higher level Transaction message which contains a type field, and a bare minimum of security stuff and some bytes",
        "ts": "1475516980.001580"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The problem I see, is that if we go and invent a new 'reconfiguration' format, that we're going to have to re-invent the security",
        "ts": "1475517059.001581"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Maybe it's a worthwhile cost, I certainly do not like the idea of trying to generate the fabric transaction format as is, it is just too complicated",
        "ts": "1475517089.001582"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "<@U0XQ35CDD> with tcerts preventing replay is O(no of reqs) and with ecerts O(no clients)",
        "ts": "1475517130.001583"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Not the same",
        "ts": "1475517138.001584"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "O(no of reqs in the epoch) which at least bounds it somewhat",
        "ts": "1475517173.001585"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "Whats an epoch",
        "ts": "1475517186.001586"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "<@U0Y14MWA2>: I may well be missing something but in the end, whether you sign with an ecert or a tcert, it's an individual transaction you need to keep track of right?",
        "ts": "1475517204.001587"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "No",
        "ts": "1475517215.001588"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I know they talked about adding an explicit epoch field, but here I am meaning it to be the window of time for which the t-cert is valid",
        "ts": "1475517226.001589"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "eCerts dictate how you do buckets (one bucket per client) but nothing prevents you from having an efficient scheme for tCerts as well.",
        "ts": "1475517232.001590"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "With ecerts you keep the last one for each client",
        "ts": "1475517236.001591"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Ah, let me know what I'm missing then.",
        "ts": "1475517238.001592"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "You keep a ts per client",
        "ts": "1475517256.001593"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(Assuming t-certs expire after 4 hours, you only need to search over however many t-certs have not expired)",
        "edited": {
            "user": "U0XPR4NP4",
            "ts": "1475517277.000000"
        },
        "ts": "1475517260.001594"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "That is diff <@U0XPR4NP4> ",
        "ts": "1475517286.001596"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "With time we can simplify replay",
        "ts": "1475517310.001597"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "At the expense of introducing time",
        "ts": "1475517324.001598"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "If I send you TX `foo` signed with my ecert, and then TX `bar` signed with my ecert, why do you only have to keep track of `bar`? Someone may well re-introduce `foo`?",
        "edited": {
            "user": "U0XQ35CDD",
            "ts": "1475517368.000000"
        },
        "ts": "1475517333.001599"
    },
    {
        "type": "message",
        "user": "U0Y14MWA2",
        "text": "There is a logical ts with both of those",
        "ts": "1475517358.001601"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XQ35CDD> because `foo` was seqNo=7 and `bar` was seqNo=8",
        "ts": "1475517360.001602"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Got it now, yup. Thanks.",
        "ts": "1475517427.001604"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XQ35CDD> So your suggestion would be we add a `Type` field to the block header which scopes the `Data` section of the block? Then what format would we use for the reconfiguration transaction?",
        "ts": "1475517502.001605"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "I was processing your earlier point before Marko chimed in with the eCert clarification. I see the concern.",
        "ts": "1475517558.001606"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "My response would be \"a much simpler format\", but then your response would be \"but then we'll have to re-invent security\", correct?",
        "ts": "1475517644.001607"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Exactly",
        "ts": "1475517651.001608"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Alright so --",
        "ts": "1475517804.001609"
    },
    {
        "type": "message",
        "user": "U0XV1HDL3",
        "text": "... re-joining for a minute ... you've summarized all points",
        "ts": "1475517852.001610"
    },
    {
        "type": "message",
        "user": "U0XV1HDL3",
        "text": "now make sure to get that across to the fabric-crypto channel!",
        "ts": "1475517864.001611"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "If we agree that the reconfigs will eventually have to go through the same kind of verification checks as standard transactions, I can see why it makes sense to make the reconfig work within the current schema.",
        "ts": "1475517888.001612"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "The concern here is:",
        "ts": "1475518012.001618"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "An inexpensive way for the peers\/orderers to realize they're dealing with a reconfig.",
        "ts": "1475518034.001619"
    },
    {
        "user": "U24PWBB97",
        "text": "<@U24PWBB97|vkandy> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1475518042.001621"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Then, regardless of whether reconfigs use the same schema as standard TXs, would you agree that labeling the AB block as of type \"reconfig\" (and having it only include this single \"tx\") would make filtering less expensive?",
        "edited": {
            "user": "U0XQ35CDD",
            "ts": "1475518166.000000"
        },
        "ts": "1475518115.001622"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Okay, I would not agree with \"easier\", but in your rephrased \"less expensive\", yes.",
        "ts": "1475518212.001625"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "However, the idea of a type scoping the contents of the block does not sit well with me",
        "ts": "1475518226.001626"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Yes, that's why I edited it. \"Easier\" was wrong.",
        "edited": {
            "user": "U0XQ35CDD",
            "ts": "1475518235.000000"
        },
        "ts": "1475518228.001627"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Especially as it is being set by the orderer.  What happens if we wish to add support for yet another transaction type.  Say UTXO?",
        "ts": "1475518255.001629"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Nothing will change. UTXO will be treated as current standard TXs are now.",
        "ts": "1475518293.001630"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Meaning that your type switch will always be:",
        "ts": "1475518319.001631"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "`select { case \"reconfig\": doFoo(); default: doBar() }`",
        "ts": "1475518343.001632"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I don't believe having to check the type of every transaction is going to be especially expensive though, considering there is a signature verification taking place already",
        "ts": "1475518358.001633"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "(Where `doBar()` is where the UTXO processing would take place.)",
        "ts": "1475518364.001634"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Less expensive yes, meaningfully so? I'm not so sure",
        "ts": "1475518368.001635"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "I believe the only way to test this accurately is by running benchmarks.",
        "ts": "1475518380.001636"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Anything else is cheap hypotheses.",
        "ts": "1475518391.001637"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "Let's narrow down a couple of our best proposals and I'll be happy to write these benchmarks.",
        "ts": "1475518421.001638"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Okay, so as I see it, there are basically 3 options:\n\n1. Re-use the fabric transaction format (hopefully a simplified version that doesn't yet exist, but the current one will do for now) and use the proposalheader type field as the type switch\n2. Create a transaction wrapper with basic security on it, with a type switch, and embed the transaction with one type, or the reconfiguration with another\n3. Add the block type header",
        "ts": "1475518514.001639"
    },
    {
        "type": "message",
        "user": "U24PWBB97",
        "text": "Hello I asked this in <#C0XR102AJ|consensus> channel but was advised to ask here. I am trying to understand *when* a block is created. The spec (<https:\/\/github.com\/hyperledger\/fabric\/blob\/master\/docs\/protocol-spec.md#3473-committing-and-rolling-back-transactions>) talks about `CommitTxBatch` but it's not clear at what point transactions are bundled to create a block. Also, what prevents a same node from creating blocks always?",
        "edited": {
            "user": "U24PWBB97",
            "ts": "1475518615.000000"
        },
        "ts": "1475518609.001640"
    },
    {
        "type": "message",
        "user": "U0XQ35CDD",
        "text": "I'm not entirely clear on #2, but we can write the protobufs tomorrow to iron the details out and then I can benchmark.",
        "edited": {
            "user": "U0XQ35CDD",
            "ts": "1475528263.000000"
        },
        "ts": "1475518612.001642"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U24PWBB97> It sounds like you are talking about the existing 0.6 release, if not the answer will be different.  When using the PBFT consensus algorithm, there is a leader election process which designates one of the nodes as the primary, who picks the contents of the next block.  The primary sends out the contents, and after a three phase protocol, the network has come to consensus about what the contents of the next block will be.  This block is now committed.",
        "ts": "1475518726.001645"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I'm not sure what you mean about a 'same node from creating blocks always'.  The guarantee with PBFT (under the fault assumptions) is that all nodes which are following the protocol will all produce the same sequence of blocks (with the same ordered contents).",
        "ts": "1475518821.001646"
    },
    {
        "type": "message",
        "user": "U24PWBB97",
        "text": "<@U0XPR4NP4> thank you - that clears up some confusion I had. I was looking at this file (<https:\/\/github.com\/hyperledger\/fabric\/blob\/master\/consensus\/executor\/executor.go>) \nRegarding the second part I guess what I am asking is can the same node be elected as a leader always therefore a single node produces blocks always. Also, if you could point me in the right direction - how often is a leader elected?",
        "edited": {
            "user": "U24PWBB97",
            "ts": "1475519258.000000"
        },
        "ts": "1475519255.001647"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U24PWBB97> You're quite welcome, and I'm happy to answer any more questions you might have.  The `executor.go` file you linked to is used to coordinate execution and state transfer, and is called asynchronously from the `pbft` package.  With classical PBFT, the leader is elected in round robin fashion.  Once a leader is chosen, the other network members watch the leader for incorrect behavior, and if they believe the leader is not acting appropriately, vote to move to the next leader.  \"Inappropriately\" can be defined especially as failing to make progress, censoring requests, or otherwise not following the protocol correctly.  Because the rest of the network is monitoring the primary's behavior, the primary may stay the leader indefinitely, so long as it behaves correctly.  Although it is not classically defined in the protocol, there is a flag in the `pbft\/config.yaml` regarding periodic view change, this causes the network to switch leaders at some multiple of every `K` blocks, regardless of the leader's integrity.   This will slow network throughput, but might be considered more 'fair' by some.",
        "ts": "1475519567.001650"
    },
    {
        "type": "message",
        "user": "U24PWBB97",
        "text": "ah! that makes sense. So I guess the primary remaining leader indefinitely isn't an issue in a permissioned chain and given that rest of the nodes are monitoring leaders action. I was looking for a way to force each node to become a leader or at least have equal chance of becoming a leader. Thanks a bunch for this information. I'll browse the pbft package.",
        "ts": "1475520263.001651"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "You're welcome, we are always here to help",
        "ts": "1475520432.001652"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XQ35CDD> <@U0XR6J961> <@U1KDAMDJ7>  <@U0UGH3X7X> <@U0UKTPMG8>  <@U0PB67X4K> <@U0KN2SSKE> <@U0S5KF44D>  Just finished a long chat with Keith about the bootstrapping issues.  I did my best to try and summarize in <https:\/\/jira.hyperledger.org\/browse\/FAB-359>",
        "edited": {
            "user": "U0XPR4NP4",
            "ts": "1475526035.000000"
        },
        "ts": "1475525986.001653"
    }
]