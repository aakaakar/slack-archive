[
    {
        "user": "U0N3AJSSU",
        "type": "message",
        "subtype": "channel_join",
        "text": "<@U0N3AJSSU|kelly> has joined the channel",
        "ts": "1461151348.000014"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yey, finally at a point where i can run bdd tests again",
        "ts": "1461163865.000015"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "what did you do ?  I'm running into connection failed  on login  in behave today",
        "ts": "1461163917.000016"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i mean after all my code changes",
        "ts": "1461163955.000017"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "<https:\/\/github.com\/corecode\/fabric\/commits\/revert-executor>",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "corecode\/fabric",
                "title_link": "https:\/\/github.com\/corecode\/fabric\/commits\/revert-executor",
                "text": "Blockchain fabric code",
                "fallback": "GitHub: corecode\/fabric",
                "thumb_url": "https:\/\/avatars3.githubusercontent.com\/u\/177979?v=3&s=400",
                "from_url": "https:\/\/github.com\/corecode\/fabric\/commits\/revert-executor",
                "thumb_width": 400,
                "thumb_height": 400,
                "id": 1
            }
        ],
        "ts": "1461164000.000018"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes, i know, a lot of commits",
        "ts": "1461164106.000020"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "jyellick, tuand: do you want to discuss the implementation for #919, #973, etc.?",
        "ts": "1461167066.000021"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XR6J961>: Yes, I've been thinking on it, haven't completely figured it out in my head yet",
        "ts": "1461167110.000022"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "My big first question would be, do you think that the plugins should share the single PBFT thread?",
        "ts": "1461167128.000023"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "what plugins?",
        "ts": "1461167163.000024"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "thursday ?  i really need to finish #756 getting through the behave tests",
        "ts": "1461167179.000025"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i think we need to continually discuss design and implementation strategies",
        "ts": "1461167210.000026"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "By plugins I mean classic\/batch\/sieve",
        "ts": "1461167376.000027"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ah yes",
        "ts": "1461167470.000028"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ideally it would just be a state machine",
        "ts": "1461167651.000029"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "event driven",
        "ts": "1461167653.000030"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and some wrapper around it serialized the events coming in",
        "ts": "1461167679.000031"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "e.g. via channel, or lock",
        "ts": "1461167687.000032"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "depending on whether the events should return an error code, or not",
        "ts": "1461167709.000033"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and then maybe we even use a FSM tool, instead of open coding the state machine as it is right now",
        "ts": "1461167752.000034"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "not talking about per-request state",
        "ts": "1461167757.000035"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but about \"in view change\", \"waiting for checkpoint\", etc.",
        "ts": "1461167784.000036"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "timer expiring then would also be an event being injected",
        "ts": "1461167824.000037"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(have to run, will respond in a bit)",
        "ts": "1461168007.000038"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "say for a timer expired event,  does that need to go the front of the queue ?",
        "ts": "1461168453.000039"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "whatever the system is that implements the event delivery, it would create\/deliver the timeout event at the right time",
        "ts": "1461168701.000040"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i think we have to implement stronger separation of concerns - smaller structures",
        "ts": "1461168757.000041"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "yes,  i'd like to see smaller components as well",
        "ts": "1461170717.000042"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "different separation than what jason's done with executor ?",
        "ts": "1461170758.000043"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i think separated code should not have its own threads\/etc",
        "ts": "1461171038.000044"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ideally",
        "ts": "1461171041.000045"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "because that just makes it so complicated to reason about",
        "ts": "1461171064.000046"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i don't even understand our test framework anymore",
        "ts": "1461171071.000047"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "behave :stuck_out_tongue_winking_eye:",
        "ts": "1461171134.000048"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yea that doesn't work well either",
        "ts": "1461171170.000049"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "some docker containers fail in my tests",
        "ts": "1461171181.000050"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "not always",
        "ts": "1461171201.000051"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "just sometimes",
        "ts": "1461171203.000052"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "not to hijack this conversation too much but i posted a behave issue in <#C0YPYBVJM> a couple days ago ... we should really have a #testing or #tools channel",
        "ts": "1461171278.000053"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "coming back to discussion, so basically components talking to each other via some sort of queues ?",
        "ts": "1461171319.000054"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "wouldn't that be <#C0YPYBVJM>?",
        "ts": "1461171322.000055"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ideally no async communication as well",
        "ts": "1461171343.000056"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i prefer as much as possible to be synchronous and encapsulated",
        "ts": "1461171354.000057"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and we need to come up with a better solution than marshalling\/unmarshalling data left and right",
        "ts": "1461171399.000058"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "it makes sense when shipping over network",
        "ts": "1461171407.000059"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "internally it just breaks static type checking",
        "ts": "1461171424.000060"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "but then haven't we serialized everything ?",
        "ts": "1461171496.000061"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes!",
        "ts": "1461171668.000062"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "all serial = no more internal races",
        "ts": "1461171695.000063"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "oh my",
        "ts": "1461171730.000064"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "i thought we were talking scalability issues as well",
        "ts": "1461171745.000065"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "now my consensus helper is supposed to signal to the consenter that the state transfer has finished",
        "ts": "1461171758.000066"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but the helper doesn't know about the consenter - only vice versa",
        "ts": "1461171772.000067"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i give up",
        "ts": "1461171842.000068"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "this code wants to be hacked, not carefully designed",
        "ts": "1461171857.000069"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "now i want to know whether state transfer works",
        "ts": "1461172464.000070"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Back.  Maybe you could help me understand why you care if\/when state transfer finishes? In general, I tried to be careful with the executor to make sure that state transfer was an atomic non-blocking operation from the orderer perspective",
        "ts": "1461173529.000071"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XR6J961>: With respect to synchronous vs asynchronous, I agree that within some unit of code, call it module say, that it makes sense to keep everything entirely synchronous.  The fact that it is possible for multiple handlers to have threads active inside PBFT at the same time today is a real problem, and there's just too much surface area for bugs to get in, we need to fix this.  The intent with the fabric code from a design perspective tries to follow the actor pattern, and it seems like it would be a good solution to this for PBFT.  Have the external methods simply queue messages into channels, then have a single thread dedicated to PBFT which selects across those channels, then performs work, and repeats.  This should eliminate all the pbft internal race bugs because everything would now be done on a single thread.  That's what I would like to implement for #919 #973",
        "ts": "1461174175.000072"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "then let's make pbft entirely event driven",
        "ts": "1461174230.000073"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and a shim that allows communication with the rest of the stack",
        "ts": "1461174250.000074"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The piece where I think I diverge from slightly from you is whether execution should be synchronous to PBFT as well.  It could obviously be done either way, but I'd be in favor of keeping the asynchronous execution model, to make a later split easier.",
        "ts": "1461174263.000075"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "that shim would also convert timeouts to events",
        "ts": "1461174264.000076"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "no, i agree that execution does not need to be synchronous",
        "ts": "1461174286.000077"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "So would you propose using something like the FSM package that is used in peer?",
        "ts": "1461174336.000078"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "in an event driven system, the fact that the stack executed a transaction would be another event, i guess",
        "ts": "1461174344.000079"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "that FSM package seems odd to use",
        "ts": "1461174356.000080"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "lots of strings",
        "ts": "1461174359.000081"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, that was my impression as well, and the fact that there are strings makes me think it's being implemented as reflection under the covers, which also seems slow.",
        "ts": "1461174377.000082"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "then pbft could send another execute",
        "ts": "1461174387.000083"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i.e. execution would be async, but always only one execution outstanding",
        "ts": "1461174432.000084"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and while we're at it, we should do the same to state transfer",
        "ts": "1461174453.000085"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i mean the conversion to events",
        "ts": "1461174494.000086"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "So help me understand this a little better.  The thing I like about the current execution model, is that in general, PBFT can treat executions as incapable of failing and atomic, even though they are not.  (Obviously this is not true for Sieve, but that is a different discussion).  If an execution can't be performed, say, because a state transfer is pending, then from PBFT's perspective, it doesn't have to care.  The only callback standard PBFT needs is the periodic checkpoint messages.  Once you switch to a model where there is only every one execution outstanding, I suppose it's PBFT who buffers the executions in the case of something like state transfer.  From a future split perspective, it seems like a queue of requests would be more scale-able, having to wait for a network round trip in between every execution seems problematic.",
        "ts": "1461174785.000087"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i don't think there will ever be such a split",
        "ts": "1461174838.000088"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "realistically speaking",
        "ts": "1461174857.000089"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I thought this was the whole endorser sort of model? Where there would be consensus as a service which is simply doing ordering, but needs to send the transaction off for execution at other nodes?",
        "ts": "1461174903.000090"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "in that case the execution would be \"add this block to the list of blocks\"",
        "ts": "1461174936.000091"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "not execution of transactions",
        "ts": "1461174949.000092"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i see your point though",
        "ts": "1461174987.000093"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but i'd prefer to have it absolutely stable before making it faster",
        "ts": "1461175014.000094"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, stability certainly takes preference over speed",
        "ts": "1461175050.000095"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "now that i hacked the code, i realize that i did have a separate thread for executions",
        "ts": "1461175062.000096"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i guess that's what your executor did - just that i absolutely had trouble following it",
        "ts": "1461175084.000097"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, the executor removed that thread and added its own (or maybe more accurately, just moved it to its own file and structure)",
        "ts": "1461175129.000098"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "So assuming we go to this event driven FSM type model",
        "ts": "1461175167.000099"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "How do you see the plugins working with this?",
        "ts": "1461175175.000100"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Do they run their own separate FSM, or do they somehow attempt to extend the underlying PBFT one?",
        "ts": "1461175201.000101"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i don't know",
        "ts": "1461175239.000102"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "it's all a mess",
        "ts": "1461175242.000103"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "probably they should run their own fsm",
        "ts": "1461175273.000104"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "or maybe not?",
        "ts": "1461175278.000105"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "they're so tied to it",
        "ts": "1461175283.000106"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "e.g. classic",
        "ts": "1461175285.000107"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The plugin piece is what has been making me scratch my head.  I think the core PBFT actually wouldn't be that difficult to clean up.  And I think batch and classic really would be trivial to move to their own FSM.",
        "ts": "1461175336.000108"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "But Sieve actually cares about PBFT internal state, like view, and timers, which is much more difficult.",
        "ts": "1461175357.000109"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but what kind of fsm would that be, for classic",
        "ts": "1461175363.000110"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I think part of the problem too is maybe that the `innerStack` interface should be broken down.  There's no reason classic and batch should be implementing different execute verify sign etc. methods.  So a FSM for classic would be pretty trivial, I'm not even sure it needs more than 1 state.  Its thread listens for incoming messages, if one arrives, it delivers, and goes back to listening.",
        "ts": "1461175534.000111"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "For batch, you would only have slightly more.  You're in that listen state, you wait for either a timer event, or the nth message, then inject.  Neither of them care about any of the rest of the innerstack interface.",
        "ts": "1461175584.000112"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "right",
        "ts": "1461175603.000113"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i don't think the plugin should have its own thread",
        "ts": "1461175640.000114"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "some state machine service should have that thread",
        "ts": "1461175654.000115"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and only delivers events to the state machine",
        "ts": "1461175666.000116"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "So a plugin would register event types (and maybe additional event sources) it's interested in?",
        "ts": "1461175764.000117"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "or it just receives them",
        "ts": "1461175790.000118"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "How would you handle if the core and a plugin were both interested in the same sort of event? Plugin supersedes?",
        "ts": "1461175796.000119"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "and optionally ignores them",
        "ts": "1461175798.000120"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i think an event always goes to a specific fsm",
        "ts": "1461175833.000121"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "in the context of FSMs",
        "ts": "1461175843.000122"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "we're far away from an event bus",
        "ts": "1461175856.000123"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I guess I'm still a little fuzzy on how say, Sieve, would be implemented in this scheme.  There's the core PBFT FSM, and it's fairly obvious how classic or batch would be implemented on top of that.  For Sieve, it could certainly inject a request into the core state machine, but how does it deal with all its other state?",
        "ts": "1461176066.000124"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i don't know",
        "ts": "1461176106.000125"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "if sieve and the pbft core (as its sub-fsm) execute within the same fsm context",
        "ts": "1461176123.000126"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "then sieve could still access the pbft internals (not saying it is a good thing)",
        "ts": "1461176138.000127"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "not modify them",
        "ts": "1461176150.000128"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but inquire",
        "ts": "1461176154.000129"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Just as another thing to keep in mind, speaking with <@U0XRC0KLH> he would like a way to publish PBFT state via an external gRPC interface.  Essentially to support dashboarding, so that a) developers can more easily debug problems without having to crawl through logs b) operators can easily verify that their systems are functioning properly and making progress.",
        "ts": "1461176269.000130"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "what kind of state would that be?",
        "ts": "1461176392.000131"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(your mentioning being able to inquire without modifying state reminded me of this)",
        "ts": "1461176396.000132"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Well, we would pick what is most useful, but I think certainly things like `lastExec`, our watermarks, if we believe we are out of sync, what view we are in, if it is active.",
        "ts": "1461176464.000133"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "formalized logging",
        "ts": "1461176504.000134"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Ultimately for operators we'll want to boil this down to a green\/red type thing, 'this node is functioning properly' or 'this node seems to be in trouble'",
        "ts": "1461176506.000135"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "But yes, formalized logging seems like a reasonable interpretation",
        "ts": "1461176532.000136"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Ultimately he would like to see it become a more system wide thing, to be able to inspect the state of the ledger, what chaincodes are deployed, etc.",
        "ts": "1461176641.000137"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ok, i gotta go soon",
        "ts": "1461176859.000138"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Okay, so getting quickly back to #919 #973, about what can be implemented in the short term.  It's certainly possible to convert all of the message reception into a channel, so that we can select across our view change  timer, or a message received channel.",
        "ts": "1461176927.000139"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "It also wouldn't be difficult to convert the Checkpoint callback to enqueue a message which could also be selected on.",
        "ts": "1461176972.000140"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "but should we do stuff for short term?",
        "ts": "1461177012.000141"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "because that's been sort of the trouble",
        "ts": "1461177021.000142"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Well, I guess with the whole agile model, we should try to accomplish something concrete in this sprint.  There are a number of outstanding bugs that are killing our scale tests because we deadlock, and I think this would fix those, and I think it would put us a little closer to a real event driven fsm.",
        "ts": "1461177096.000143"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes",
        "ts": "1461177111.000144"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "do we know what deadlocks precisely?",
        "ts": "1461177122.000145"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I can enumerate some of them.  One is that because we drop the lock around executions, the executions can actually be invoked out of order",
        "ts": "1461177157.000146"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Which causes the blockchains to diverge and pbft to stop making progress",
        "ts": "1461177180.000147"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ah what?",
        "ts": "1461177203.000148"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I have seen it in the logs, we'll get something like\n\nexecuting\/committing seqNo 35\nexecuting\/committing seqNo 36\nexecuting\/committing seqNo 37\nexecuting\/committing seqNo 34\nexecuting\/committing seqNo 38",
        "ts": "1461177253.000149"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "how is that possible",
        "ts": "1461177291.000150"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Well, maybe not that exactly line, sorry",
        "ts": "1461177295.000151"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yea",
        "ts": "1461177298.000152"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Let me get the real log",
        "ts": "1461177301.000153"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "If I still have it...",
        "ts": "1461177306.000154"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Ah, damn, blew them away to run the behave tests",
        "ts": "1461177388.000155"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, on line 785, we increment `lastExec`, then we drop the lock, and send the exec off",
        "ts": "1461177478.000156"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "As soon as we drop that lock, another handler thread can come in, and do its own thing",
        "ts": "1461177503.000157"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "And so if the thread happens to get unscheduled before we actually run the invoke, then things break, I suppose that might be fixed by simply setting the lastExec after we send the execute",
        "ts": "1461177536.000158"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "But we drop and re-acquire these locks far to often, and it just invites these sorts of bugs",
        "ts": "1461177596.000159"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "yes",
        "ts": "1461178032.000160"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "absolutely agree",
        "ts": "1461178037.000161"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i think i made exec synchronous again",
        "ts": "1461178047.000162"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "which breaks all soft of other things, because that deploy takes forever",
        "ts": "1461178059.000163"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, it seems like deploys are going to need to be restricted in any sort of production system, they are such an easy DOS path",
        "ts": "1461178164.000164"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "<https:\/\/github.com\/corecode\/fabric\/commits\/revert-executor>",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "corecode\/fabric",
                "title_link": "https:\/\/github.com\/corecode\/fabric\/commits\/revert-executor",
                "text": "Blockchain fabric code",
                "fallback": "GitHub: corecode\/fabric",
                "thumb_url": "https:\/\/avatars3.githubusercontent.com\/u\/177979?v=3&s=400",
                "from_url": "https:\/\/github.com\/corecode\/fabric\/commits\/revert-executor",
                "thumb_width": 400,
                "thumb_height": 400,
                "id": 1
            }
        ],
        "ts": "1461178169.000165"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "or we make deploy execution asynchronous",
        "ts": "1461178183.000167"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "i'd love to get some feedback on this",
        "ts": "1461178199.000168"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "ok, now i'm really out",
        "ts": "1461178223.000169"
    },
    {
        "type": "message",
        "user": "U0XR6J961",
        "text": "byes",
        "ts": "1461178225.000170"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Was reviewing your code",
        "ts": "1461178799.000171"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "we should discuss deploy.  it's being done wrong today, b\/c there's no in-state row for a deploy",
        "ts": "1461179174.000172"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XRC0KLH>: Did I appropriately summarize your desires for the pbft state introspection interface?",
        "ts": "1461179314.000173"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "uh, voice?",
        "ts": "1461179342.000174"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "yes, that summary was spot-on",
        "ts": "1461179356.000175"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "re: deploy",
        "ts": "1461179361.000176"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Above, I tagged you many messages above here, sorry, slack not great about that",
        "ts": "1461179379.000177"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "I saw it",
        "ts": "1461179388.000178"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "slack is at least good thatway",
        "ts": "1461179393.000179"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "it ws fine",
        "ts": "1461179395.000180"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "oof, incoming",
        "ts": "1461179403.000181"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "will IM bakc",
        "ts": "1461179404.000182"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Alright",
        "ts": "1461179407.000183"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "but deploy is all worng",
        "ts": "1461179410.000184"
    },
    {
        "type": "message",
        "user": "U0UGH3X7X",
        "text": "<@U0KN2SSKE>:  <@U0ULK2JPP>  see above re: deploy",
        "ts": "1461179468.000185"
    },
    {
        "user": "U0KN2SSKE",
        "inviter": "U0UGH3X7X",
        "type": "message",
        "subtype": "channel_join",
        "text": "<@U0KN2SSKE|binhn> has joined the channel",
        "ts": "1461179475.000186"
    },
    {
        "user": "U0ULK2JPP",
        "inviter": "U0UGH3X7X",
        "type": "message",
        "subtype": "channel_join",
        "text": "<@U0ULK2JPP|muralisr> has joined the channel",
        "ts": "1461179475.000187"
    },
    {
        "type": "message",
        "user": "U0TFEHX8E",
        "text": "<@U0XRC0KLH>: are you talking about <https:\/\/github.com\/hyperledger\/fabric\/issues\/1054> or something else?",
        "edited": {
            "user": "U0TFEHX8E",
            "ts": "1461179582.000000"
        },
        "ts": "1461179577.000188"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "right, but that doesn't go far enough",
        "ts": "1461181349.000191"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "deployed chaincode needs to have a \"state\".",
        "ts": "1461181363.000192"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "so for instance: \"maintenance\", \"active\"",
        "ts": "1461181382.000193"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "but also, since apparently building the chaincode is taking nontrivial time, \"installed\"",
        "ts": "1461181407.000194"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "erm, \"committed\"",
        "ts": "1461181422.000195"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "committed == committed to state (sysibm.sysprocedures)",
        "ts": "1461181435.000196"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "which causes a background thread to attempt to build the chaincode image",
        "ts": "1461181451.000197"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "eventually, a tran would be run at ALL endorsers with some HIGH threshold for success, that would move the chaincode from committed to maintenance",
        "ts": "1461181505.000198"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "in maintenance, only users with maintainer rights could invoke trans on it.",
        "ts": "1461181525.000199"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "e.g. to call\"init\"",
        "ts": "1461181528.000200"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "and then finaly, move it to \"active\" so all users with rights can access it",
        "ts": "1461181541.000201"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "at a minimum, EVEN IF chaincode image creation is instant, we need maintenance and active",
        "ts": "1461181602.000202"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "b\/c a single init() call might not be enough to get teh chaincode ready for use",
        "ts": "1461181615.000203"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "remember that an init() call is a tran like any other, so will be limited in how many rows it can modify",
        "ts": "1461181639.000204"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "this is the equiv of: when I deploy a stored-proc, I need to create the tables it accesses, and load initial data into some of them",
        "ts": "1461181663.000205"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "that isnt' guaranteedto fit in a 5M shellscript",
        "ts": "1461181673.000206"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "<@U0XRC0KLH>: the \u201cdeploy state\u201d caught the eye\u2026. don;t want to derail the rest of the discussion but the system chaincode (lifecycle, deploy, \u2026we can decide what to call later) will *naturally* provide the way to create a \u201cstate\u201d for deployed chaincodes.",
        "ts": "1461181832.000207"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "does that fall in line with your thinking \u2026 again, didn;t want to derail the discussion\u2026.",
        "ts": "1461181865.000208"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "the table sysibm.chaincodes will have schema",
        "ts": "1461181873.000209"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "ccid &lt;long-integer&gt;, body blog, state {MAINT,ACTIVE}",
        "ts": "1461181891.000210"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "primary key ccid",
        "ts": "1461181896.000211"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "perhaps other colums, like a list of certs who are allowed to invoke maintenance operations on it",
        "ts": "1461181919.000212"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "yep",
        "ts": "1461181939.000213"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "and when the (deploy) system chaincode receives a tran to deploy the chaincode, it\u2019ll manip. sysibm.chaincodes",
        "ts": "1461181987.000214"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "right",
        "ts": "1461181993.000215"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "the chaincode -buid- process will be -driven- by the state of sysbm.chaincodes and differences between that, and what's on-disk",
        "ts": "1461182021.000216"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "right",
        "ts": "1461182047.000217"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "basically... the system chaincode acts as a filter for deploy (and other trans) and being itself a chaincode (as opposed to code embedded in fabric as it is today) can access state naturally.  Opens up avenues",
        "ts": "1461182243.000218"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "<@U0XRC0KLH>:  did that capture it ? anything else you\u2019d add\/change ?",
        "ts": "1461182318.000219"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XR6J961>: <https:\/\/github.com\/jyellick\/fabric\/pull\/1\/> You can see my comments on your branch here (sorry for the clunkiness of doing it in a PR by me against my own fork, I did not want to submit your code to the hyperledger fabric project as a PR to discuss if you didn't want it there yet), most of my concerns are around state transfer with the executor removed.  I don't think they are beyond addressing, the pre #833 code handled some of these cases, but we are getting right back into having pbft and state transfer far too intertwined in eachother's workings, which was one of the principle reasons for pushing it into its own module.",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "Revert executor review by jyellick \u00b7 Pull Request #1 \u00b7 jyellick\/fabric \u00b7 GitHub",
                "title_link": "https:\/\/github.com\/jyellick\/fabric\/pull\/1\/",
                "text": "@corecode Was trying to figure out a way to comment on your changes, this is inelegant, but at least I can comment on things somewhat line by line.",
                "fallback": "GitHub: Revert executor review by jyellick \u00b7 Pull Request #1 \u00b7 jyellick\/fabric",
                "thumb_url": "https:\/\/avatars0.githubusercontent.com\/u\/7431583?v=3&s=400",
                "from_url": "https:\/\/github.com\/jyellick\/fabric\/pull\/1\/",
                "thumb_width": 420,
                "thumb_height": 420,
                "id": 1
            }
        ],
        "ts": "1461182799.000220"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I've actually been thinking that my biggest mistake with the executor split was attempting to create one executor to serve both sieve and classic\/batch, when their execution models are so different.  Sieve must only ever have one request in the queue at a time, so trying to use an asynchronous queue based system doesn't make a lot of sense there.  Similarly, Sieve can provide a checkpoint to transfer to at every round of consensus, so the feeding of checkpoints from PBFT is largely superfluous.  On the other hand, the executor removed a lot of the complexity of state transfer out of `pbft-core.go`.  I think it would be possible to rip the sieve support components out of the executor, which would drastically simplify it, then have Sieve perform its own executions or implement a much simpler more sycnhronous executor for Sieve.",
        "ts": "1461183222.000222"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "<@U0XPR4NP4> might as well just rip out Sieve.  It's a broken protocol anyway.  No replayability, what's the point of its existence.",
        "ts": "1461190377.000223"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "effort spent maintaining it is wasted effort",
        "ts": "1461190393.000224"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "<@U0XRC0KLH>: I can't comment on sieves design or status, but I can say that consensus algorithms that perform EV are mandatory (to me) and I don't think PBFT provides that.  At least, not in this context.  What are your thoughts or that?",
        "ts": "1461191641.000225"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "The notion that sieve can be arbitrarily abandoned concerns me.",
        "ts": "1461191696.000226"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "What is the replay problem you mention by the way?",
        "ts": "1461191785.000227"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "<@U0KPFAZNF> have you seen this? <https:\/\/github.com\/chetmurthy\/fabric-wiki\/blob\/master\/chet-arch\/mvcc%2Bpostimage.txt>",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "chetmurthy\/fabric-wiki",
                "title_link": "https:\/\/github.com\/chetmurthy\/fabric-wiki\/blob\/master\/chet-arch\/mvcc%2Bpostimage.txt",
                "text": "Contribute to fabric-wiki development by creating an account on GitHub.",
                "fallback": "GitHub: chetmurthy\/fabric-wiki",
                "thumb_url": "https:\/\/avatars0.githubusercontent.com\/u\/1755771?v=3&s=400",
                "from_url": "https:\/\/github.com\/chetmurthy\/fabric-wiki\/blob\/master\/chet-arch\/mvcc%2Bpostimage.txt",
                "thumb_width": 420,
                "thumb_height": 420,
                "id": 1
            }
        ],
        "ts": "1461191830.000228"
    },
    {
        "text": "looks",
        "type": "message",
        "subtype": "me_message",
        "user": "U0KPFAZNF",
        "ts": "1461191853.000230"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "also, there's a note -in- this note, with subject \"trading latency ...\"",
        "ts": "1461191873.000231"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "<https:\/\/github.com\/chetmurthy\/fabric-wiki\/blob\/master\/chet-arch\/confidential-data.txt>",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "chetmurthy\/fabric-wiki",
                "title_link": "https:\/\/github.com\/chetmurthy\/fabric-wiki\/blob\/master\/chet-arch\/confidential-data.txt",
                "text": "Contribute to fabric-wiki development by creating an account on GitHub.",
                "fallback": "GitHub: chetmurthy\/fabric-wiki",
                "thumb_url": "https:\/\/avatars0.githubusercontent.com\/u\/1755771?v=3&s=400",
                "from_url": "https:\/\/github.com\/chetmurthy\/fabric-wiki\/blob\/master\/chet-arch\/confidential-data.txt",
                "thumb_width": 420,
                "thumb_height": 420,
                "id": 1
            }
        ],
        "ts": "1461191874.000232"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "same general subject",
        "ts": "1461191877.000234"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "the reason state-machine replication is needed that we execute chaincode 'everywhere'",
        "ts": "1461191899.000235"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "that isn't scalable to begin with",
        "ts": "1461191904.000236"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "once you ditch that assumption, you can make HL be a normal database with a cryptographically protected log",
        "ts": "1461191934.000237"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "that way lies throughput",
        "ts": "1461191940.000238"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "Re: \"replay\", sieve doesn't guarantee that when an auditor replays a tran, it will have the same effect as when it was committed.  So it's entirely possible to be unable to audit a log by replaying it (and since logs don't contain state-deltas, there's no other way to audit a log)",
        "ts": "1461192150.000239"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "by contrast, \"MVCC+postimage\" \"locks down\" one of the nondeterministic executions of a tran.  So even if, at replay time, the tran does something different, the auditor can just apply the state-delta and move past that tran (unless they're actually interested inthe tran, in which case, they could investigate further the discrepancy, knowing 100% that it's just a non-replayability issue, not some other bug.",
        "ts": "1461192528.000240"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "So you are worried about a scenario where a given transaction was deterministic enough that 2f+1 validators computed the same hash...but later an auditor cannot reproduce the same result?",
        "ts": "1461193935.000241"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "well, if we admit nondeterminstic trans, that's always a possibility.",
        "ts": "1461194138.000242"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "whereas, with MVCC+postimage, we -know- what teh state-delta is.",
        "ts": "1461194148.000243"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "sure, the replay of the tran might produce something different.  But we still know what was applied at commit, and we cna apply it again",
        "ts": "1461194163.000244"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "I gotta run (sister just had twins!  time to visit hospital!) but we can talk another time.",
        "ts": "1461194185.000245"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "Ok, congrats!",
        "ts": "1461194199.000246"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "I totally understand the argument of MVCC as a vehicle for concurrency, but it seems some of the other issues are being conflated",
        "ts": "1461194261.000247"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "I'd like to understand more, so ping when you are back",
        "ts": "1461194276.000248"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0KPFAZNF>: Just for clarification, in Sieve, it only takes f+1 votes of confidence in the same answer to be committed",
        "ts": "1461198319.000249"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XRC0KLH>: With respect to ripping out Sieve, I certainly agree that Sieve makes no sense in a post MVCC world, and I'm all in favor of not maintaining code that does not have a long term home.  Of course today, Sieve is the only option we have to tolerate chaincode which does not behave in a deterministic way, and I know <@U0XR6J961> especially and others (including myself) have put a lot of time into making Sieve functional.  I'd like to assume there is some sort of 'must have for this release' requirement that we have been trying to satisfy?",
        "edited": {
            "user": "U0XPR4NP4",
            "ts": "1461211388.000000"
        },
        "ts": "1461198637.000250"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "<@U0XPR4NP4>: i think that makes sense, or at least it doesnt jump out at me as wrong",
        "ts": "1461198642.000251"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "most of these designs fall somewhere in the range of f+1 to 2f+1 to be correct :wink:",
        "ts": "1461198684.000253"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "its not always clear when you can cheat back from 2f+1, but I know there are many opportunities to do so",
        "ts": "1461198718.000254"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Haha, very true, not a huge deal, unless you are truly interested in understanding the inner workings of Sieve.  The high level \"All the replicas will end up with the same state, even if transactions are behaving nondeterministically, and a byzantine replica will not generally be able to pick that state.\" is usually good enough.",
        "edited": {
            "user": "U0XPR4NP4",
            "ts": "1461198923.000000"
        },
        "ts": "1461198734.000255"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "anyway, I dont have a strong opinion on what the consensus algorithm is as long as it performs at scale and verifies outputs",
        "ts": "1461199594.000258"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "if the mvcc work ends up being that and sieve gets deprecated, that is fine by me",
        "ts": "1461199641.000259"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "i would just hate to see pbft become the only option, as I dont think it will work for me",
        "ts": "1461199654.000260"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0KPFAZNF>: To me, the crux of the problem, is that you can take the output of 10 million trusted nodes all running the same code, and get the same result, and that's not good enough to say that it's actually deterministic.  It's very possible to prove non-determinism from transaction output, but never to prove determinism.  So, you always run the risk that the auditor comes by and replays that transaction and says \"Hey, why is my result different?\".  Now, you can certainly say, that you had a quorum which must have agreed on whatever the output was, but unless you analyze the input itself, you can't make that determinism guarantee.  Which is why the MVCC promise is not that the underlying chaincode is deterministic, but the application of the transaction is.",
        "ts": "1461200406.000261"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "i understand that part: to play back..",
        "ts": "1461200499.000262"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "we agree that only deterministic results are valid, and consensus tries to ensure that at least enough nodes agree that the results were deterministic (among other criteria)",
        "ts": "1461200541.000263"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "but there is never a guarantee that operations truely are deterministic\u2026we could have 2f+1 that says it was but the auditor is the unlucky one that found out it isnt",
        "ts": "1461200577.000264"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "so what we want to do is prevent this from somehow impacting replay\/auditability",
        "ts": "1461200610.000265"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "or minimize it at least",
        "ts": "1461200624.000266"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "it seems that the argument is that mvcc is more resistant to negative impact of non-determinism because the state delta may still be applied even if the process that generated the state delta cannot be reliably reproduced?",
        "ts": "1461200683.000267"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Right, so, MVCC has the advantage that it knows the correct output when trying to come to consensus.  Sieve has the much harder task of trying to determine the correct output from among a group of byzantine peers, then come to consensus.",
        "edited": {
            "user": "U0XPR4NP4",
            "ts": "1461200823.000000"
        },
        "ts": "1461200800.000268"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "ok, i am not sure I fully understand the details on your last statement, but lets back burner that for a second",
        "ts": "1461200834.000271"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "the problem I am having (and this is not sieve\/mvcc specific, but just general) is that I dont see the notion of \u201cstate\u201d vs \u201cstate hash\u201d as being a property that is exclusive to the consensus algorithm",
        "ts": "1461200886.000272"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "In the MVCC model, the 'state hash' no longer needs to be in the block, because replaying the transactions is guaranteed to produce the same result.",
        "ts": "1461200974.000273"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "yes, there are differences \u201con the wire\u201d and even \u201con the block\u201d, but ultimately the notion of \u201cstate at a point in time\u201d or \u201cstate deltas\u201d seem to be data that either explicitly exists or could be synthesized at any point in time based on the fact that a \u201cblockchain\u201d is essential a record of exactly that",
        "ts": "1461200976.000274"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "so I am not seeing why mvcc buys this replay resistance over other models (at least ones that do EV)",
        "ts": "1461201013.000275"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "right, but \u201con the block\u201d optimizations are different from the data existing or at least being capable of synthesis",
        "ts": "1461201070.000276"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "i agree on the block models differ, but the state should ultimately be available either way (it has to be)",
        "ts": "1461201102.000277"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "The hope is that you could synthesize the a state delta from the transactions at any point in time, but with non-determinism that's not the case.  Today, we discard the state deltas because of space considerations.  So, you can know what the state hash was at a block, but unless you can replay those transactions successfully, unless you have a copy of that state, or retained the state deltas, it's possible in the worst case you can never recreate that state.",
        "ts": "1461201125.000278"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "In MVCC the transaction is essentially a state delta, it is the keys, and their version, and what they are updated to.",
        "ts": "1461201223.000279"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "ok, lets walk a scenario though: say I have some state with 100 mutations",
        "ts": "1461201247.000280"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "start at mutation 0 with empty rows and grow over time to 100 versions",
        "ts": "1461201269.000281"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "and those 100 versions all had at least 2f+1 commit certificates, etc, were considered value",
        "ts": "1461201311.000282"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "valid",
        "ts": "1461201312.000283"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "then someone tries to audit the sequence, and when they get to block 50 there is some non deterministic function that cant reproduce the same result",
        "ts": "1461201361.000284"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "in one model, we stored 100 state hashes \u201cin the block\"",
        "ts": "1461201393.000285"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "in the other, we recorded 100 mvcc+postimage objects",
        "ts": "1461201411.000286"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "if I understand the argument, its that we are saying even though we cant reproduce the result at block 50, we can still apply block 50 because the mvcc data is sufficient to get to block 51",
        "ts": "1461201482.000287"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "is this right so far?",
        "ts": "1461201524.000288"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, so far so good",
        "ts": "1461201531.000289"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "ok, so neither model is sufficient at eliminating the non-determinism (nothing is), but we can at least move on to block 51 with mvcc rather than stall the whole process",
        "ts": "1461201592.000290"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yep, exactly.",
        "ts": "1461201640.000291"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "so what I dont see is why mvcc is providing an advantage:  in theory, any of the other nodes should be able to provide\/synthesize the necessary state if we ask them in either model",
        "ts": "1461201719.000292"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "i should be able to ask one of the other nodes for block 50, or ask for the delta between 49 and 50, or whatever, regardless of model",
        "ts": "1461201747.000293"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "right?",
        "ts": "1461201754.000294"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "or am I missing something",
        "ts": "1461201758.000295"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "just because the on block representation is just a hash doesnt mean the state no longer exists (conceptually, anyway)",
        "ts": "1461201786.000296"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Ah, so, if the transaction is truly non-deterministic, a node executing it again doesn't guarantee it will get the same result",
        "ts": "1461201812.000297"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "if we elided the state for space optimization or something, that is one thing",
        "ts": "1461201813.000298"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Consider a really silly chaincode which returns 0 until 2017, then returns 1 ever after.",
        "ts": "1461201830.000299"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "ok",
        "ts": "1461201838.000300"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "If the transaction executes in 2016, everyone will agree the output is 0, and then in 2017 the auditor comes along and tries to get back to that state.",
        "ts": "1461201850.000301"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "got it, but that is true regardless of model",
        "ts": "1461201869.000302"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Well, in MVCC, the auditor would see, that when this was executed, 2f+1 nodes agreed that the output was 0",
        "ts": "1461201898.000303"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "i think they would see that either way, no?",
        "ts": "1461201921.000304"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "And so although the auditor may not be happy about that, that's much better than the alternative that \"2f+1 nodes agreed on that output\"",
        "ts": "1461201938.000305"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "So, in the non-MVCC case,there's no way to recover that the output was 0",
        "ts": "1461201952.000306"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "You only know if you got the same output, not what the old output was",
        "ts": "1461201967.000307"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "block 50 would have a state-hash with 2f+1 signatures, and if you ask any of those nodes for the state corresponding to the hash, it should have 0 amongst its rows",
        "ts": "1461201978.000308"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(in the case of where they're different)",
        "ts": "1461201979.000309"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Ah, but nodes do not retain state for every block",
        "ts": "1461201991.000310"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "So they say \"I garbage collected that ages ago, I don't know what that state was, just what it's hash was\"",
        "ts": "1461202008.000311"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "it sounds like this is more of a case of the ledger introspection features than a property of the why states are represented on the block",
        "ts": "1461202009.000312"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "If we stored the state deltas indefinitely, then you could get replayability",
        "ts": "1461202047.000313"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "you could certainly argue that the internal representation is based on state deltas that are retrievably via state hash",
        "ts": "1461202062.000314"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "right",
        "ts": "1461202068.000315"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "and that is kind of what mvcc is doing, just at a higher level",
        "ts": "1461202079.000316"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "No, that's the whole idea of a hash, it's one way, you can't reverse engineer a state from its hash",
        "ts": "1461202085.000317"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Once a state delta is garbage collected, it is gone forever, unless you can reproduce it by replaying the transactions",
        "ts": "1461202117.000318"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(Which is true, so long as your replay is determinstic)",
        "ts": "1461202131.000319"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "understood that you cant from the hash itself, but the on-block representation of a state-hash is there for the purposes of protocol efficiency, not data obscurity\u2026the assumption would be that you should be able to query a hash back to a state value",
        "ts": "1461202164.000320"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "There is no facility to do that today, and I don't think it's planned.  You can ask for a state delta by block number, but by default I believe we only retain the last 500 of them.",
        "ts": "1461202223.000321"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "ok, thats fine\u2026 i didnt mean to comment on impl status, just conceptual understanding",
        "ts": "1461202245.000322"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Certainly retaining a whole copy of the state per block is probably infeasible.  Retaining the deltas indefinitely is in a sense what MVCC is doing.",
        "ts": "1461202251.000323"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(But MVCC also brings some other benefits, like scale)",
        "ts": "1461202263.000324"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "my main point is, i dont think MVCC buys us this resistance, its the data model that buys it",
        "ts": "1461202267.000325"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "right, MVCC is useful in other capacities, like concurrency and thus scale",
        "ts": "1461202287.000326"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "you can have a state-delta strategy that is independent of the MVCC debate, thats all I am saying",
        "ts": "1461202317.000327"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Ah, yes, sorry for being dense, that's certainly true.",
        "ts": "1461202328.000328"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "I am not arguing that we should do something other than MVCC either, dont get me wrong",
        "ts": "1461202346.000329"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Well, one thing though",
        "ts": "1461202349.000330"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "State deltas are per block.",
        "ts": "1461202360.000331"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "What if I have 2 transactions in my block, and I replay them, and I get a different result.",
        "ts": "1461202384.000332"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Then I can see what the aggregate effect of the 2 transactions was, but, I can't actually determine which is behaving non-deterministically.",
        "ts": "1461202412.000333"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "(Assuming they both modify the same values)",
        "ts": "1461202441.000334"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "well to be clear, i dont think you want to compress transactions to the block level",
        "ts": "1461202442.000335"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "i envision the finest granularity for the hash is the transaction level, a block would just encompass N transactions (and thus N hashes)",
        "ts": "1461202470.000336"
    },
    {
        "user": "U0J5URUJU",
        "type": "message",
        "subtype": "channel_join",
        "text": "<@U0J5URUJU|nycnewman> has joined the channel",
        "ts": "1461202490.000337"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "Yes, you could implement it this way, but that is not the current block implementation.",
        "ts": "1461202491.000338"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "sure, thats fair",
        "ts": "1461202499.000339"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "again, just conceptual",
        "ts": "1461202503.000340"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "i actually havent had a chance to study what sieve is doing in reality",
        "ts": "1461202519.000341"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "There's a paper around here somewhere I could probably dig up if you are interested, or I could try to quickly walk you through it at some point if you'd like.",
        "ts": "1461202549.000342"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "but ultimately, i think even the on-wire\/on-block stuff should never go coarser than transaction-level hash",
        "ts": "1461202561.000343"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "i assume you are talking about the sieve paper?  if so, link apprecated",
        "ts": "1461202596.000344"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "i saw it go by while I was traveling a few weeks ago but I have lost track of the link",
        "ts": "1461202610.000345"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "I believe this is the paper <http:\/\/arxiv.org\/abs\/1603.07351>",
        "ts": "1461202714.000346"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "<@U0XR6J961> Would be a better person to ask",
        "ts": "1461202722.000347"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "awesome, thank you",
        "ts": "1461202726.000348"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "No problem",
        "ts": "1461202741.000349"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "going to go eat dinner, thanks for the chat",
        "ts": "1461202809.000350"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "will talk more",
        "ts": "1461202812.000351"
    },
    {
        "type": "message",
        "user": "U0XPR4NP4",
        "text": "No problem, always happy to help, just let me know",
        "ts": "1461202834.000352"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "MVCC does not offer \"replay resistance\" in the way tnat Bitcoin does.   But there's a minor extnesion to the design, that -does- offer such",
        "ts": "1461207418.000353"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "\"just because the on block representation is just a hash doesnt mean the state no longer exists (conceptually, anyway)\"  ... Actually, YES",
        "ts": "1461207503.000354"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "you would NOT want to have a database that kept full per-tran state-snapshots around.  That would be .... immense",
        "ts": "1461207526.000355"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "uncontainably immense",
        "ts": "1461207531.000356"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "something that's not clear is: MVCC+postimage is -just- the way normal databses do it",
        "ts": "1461207551.000357"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "\"you can have a state-delta strategy that is independent of the MVCC debate\" .... if you keep only postimages (== state deltas) you cannot provide a reasonable concurrency-control model.",
        "ts": "1461207602.000358"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "you might wish to look at Alonso &amp; Kemme, on the Dragon system",
        "ts": "1461207616.000359"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "Christian Cachin pointed out that what I proposed is effectively the same as what they did in that work",
        "ts": "1461207636.000360"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "The MVCC information corresponds to the locks that the tran woud take, and the postimage data corresponds to the REDO information in a typical transaction log.",
        "ts": "1461208046.000361"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "we're merely doing what databases do.",
        "ts": "1461208055.000362"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "<@U0XRC0KLH>: i think we are saying the same thing",
        "ts": "1461208232.000363"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "when I said state exists, i meant logically",
        "ts": "1461208248.000364"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "as in, \u201cstate\u201d can be a synthesis of a composition of deltas",
        "ts": "1461208272.000365"
    },
    {
        "type": "message",
        "user": "U0KPFAZNF",
        "text": "and that is exactly my point: the structure that mvcc in terms of state deltas isnt really any different than what another design would be doing as well",
        "ts": "1461208333.000366"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "this is probably easier to discuss interactively by voice than in a chat . But actually, no, MVCC+postimage provides \"proper concurrency control\", whereas state deltas alone do not.",
        "ts": "1461208780.000367"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "this is where the Dragon paper might be useful",
        "ts": "1461208797.000368"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "I will not claim that I was inspired by that work, but it's fair to say that they're prior, and their design considerations were similar to what drove me in this MVCC+postimage design",
        "ts": "1461208835.000369"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "MVCC is the locks that would be acquired in a standard-issue lock-manager-based DB",
        "ts": "1461208848.000370"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "postimage is -just- what would go in the tran-log",
        "ts": "1461208855.000371"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "and the combination of MVCC+postimage allows us to eschew the lock-manager.  I can explain sometime more fully by voice",
        "ts": "1461208874.000372"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "I'll put it this way: not that you'd want to do this, but you could imagine an application that does queries on a peer, and paints a screen; the application would ask the peer to take a (non-durable) snapshot, aaginst which the queries were run.  Say, a trading screen.",
        "ts": "1461208940.000373"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "later, when the trader presses \"buy\", the tran would be \"simulated\" against the actual state-snapshot that was used to paint the screen; then, it would be re-simulated against the current state of the peer, and if the MVCC+postimage info differed, the trader would get a \"stuff changed while you were getting coffee; here's a repaint, do you still want to buy?\" message",
        "ts": "1461209003.000374"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "this is simply not possible without version-numbers and MVCC information",
        "ts": "1461209020.000375"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "similarly, one can be validating trans in parallel and know that if they're valid, they can be sequenced in any order, and as long as all replicas apply those trans in that same order, eacn tran will either execute as it did when it was validated, OR it will abort.",
        "ts": "1461209082.000376"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "these properties are analogous to the properties you'd get in a normal database",
        "ts": "1461209094.000377"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "and NOT what you'd get in ethereum",
        "ts": "1461209098.000378"
    },
    {
        "type": "message",
        "user": "U0XRC0KLH",
        "text": "(for instance)",
        "ts": "1461209100.000379"
    }
]