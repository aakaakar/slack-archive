[
    {
        "user": "U1BC5A0F9",
        "text": "<@U1BC5A0F9|elli> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1486047032.000002"
    },
    {
        "user": "U1BC5A0F9",
        "purpose": "Discuss potential security concerns of the new deployment model",
        "text": "<@U1BC5A0F9|elli> set the channel purpose: Discuss potential security concerns of the new deployment model",
        "type": "message",
        "subtype": "channel_purpose",
        "ts": "1486047032.000003"
    },
    {
        "user": "U0ULK2JPP",
        "inviter": "U1BC5A0F9",
        "text": "<@U0ULK2JPP|muralisr> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1486047032.000004"
    },
    {
        "user": "U0ZR63HLK",
        "inviter": "U1BC5A0F9",
        "text": "<@U0ZR63HLK|adc> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1486047032.000005"
    },
    {
        "user": "U2GFYLYN8",
        "inviter": "U1BC5A0F9",
        "text": "<@U2GFYLYN8|mneug> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1486047032.000006"
    },
    {
        "user": "U26T99AQ4",
        "inviter": "U1BC5A0F9",
        "text": "<@U26T99AQ4|aso> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1486047033.000007"
    },
    {
        "user": "U0KN2SSKE",
        "inviter": "U1BC5A0F9",
        "text": "<@U0KN2SSKE|binhn> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1486047033.000008"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "Hi all, I created this channel to discuss security of the new deployment model",
        "ts": "1486047064.000009"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "some background: <@U0ZR63HLK> talked to <@U0ULK2JPP> yesterday, and among others, there were two interesting points",
        "ts": "1486047117.000010"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "1) that with the new model there is one container the chaincode runs in regardless of the chain this chaincode is running for; what changes is the context this chaincode is invoked for (an object referenced by the id of the transaction that invoked that chaincode txid )",
        "ts": "1486047216.000011"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "2) that upon a chaincode invoking getState(key), the Shim retrieves the txid the invocation is connected to and sends to the peer a getState(key, txid) message that would enable the peer to retrieve the context the chaincode was invoked for (recall, it is referenced using the txid) and respond accordingly. From what <@U0ZR63HLK> explained there is no strong binding between the connection a peer has with a chaincode and the txid (actual context that should follow that invocation)",
        "ts": "1486047573.000012"
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "both correct Elli",
        "ts": "1486047694.000013"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "also maybe a point 3) TLS connection between a chaincode and the peer is only peer-side authenticated",
        "ts": "1486047803.000014"
    },
    {
        "type": "message",
        "user": "U2GFYLYN8",
        "text": "so (1) weakens the isolation between chains by having one chaincode instance handle multiple chains. In the presence of an attacker that can compromise chaincode by invoking it, such an attacker would thus gain access to all chains that the chaincode is being used for.",
        "ts": "1486048200.000015"
    },
    {
        "type": "message",
        "user": "U2GFYLYN8",
        "text": "for (2) a compromised chaincode could just use any transaction ID (because it is not bound to its connection with the peer)",
        "ts": "1486048364.000016"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "and in that case (2) if there are other chaincodes being invoked at the same time, as the compromised\/malicious one, the latter could get other chain's chaincode's state",
        "ts": "1486048601.000017"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "(?)",
        "ts": "1486048605.000018"
    },
    {
        "type": "message",
        "user": "U2GFYLYN8",
        "text": "so based on my understanding this could only happen if the benign chaincode's handler is unregistered for some reason and the malicious chaincode registers with the benign chaincode's ID. because the chaincode ID is bound to the handler\/connection",
        "ts": "1486048823.000019"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "Ok, So you are saying that apart from the txid that the chaincode \/ shim sends to the peer, the peer also checks the txid the connection is bound to prior to sending context (state) info to the chaincode (?)",
        "ts": "1486048964.000020"
    },
    {
        "type": "message",
        "user": "U2GFYLYN8",
        "text": "no, I don't think I said that :slightly_smiling_face:\nI was merely referring to the chaincode ID",
        "ts": "1486049082.000021"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "Ok, discussed with <@U2GFYLYN8> and arrived to the following conclusions (<@U2GFYLYN8>, please correct me if i m wrong):",
        "ts": "1486056974.000022"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "a) When a chaincode is invoked or actually launched there the peer binds the connection to the container (handler) to the chaincode identifier. The peer also constructs a transaction context object, that is referenced by the transaction identifier and includes also chaincode identifier in it. Now, we should ensure that whenever the chaincode requests state \"getState(txid, key)\" or \"setState(txid, key, value)\" the peer needs to check that the txcontext object referenced by \"txid\" corresponds indeed to a chaincode with the same chaincode identifier as the one the connection is bound to.",
        "ts": "1486057214.000023"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "Here we assumed that there is at most *one* instance of a given chaincode that is running on the peer at each time. <@U0ULK2JPP>, please confirm that this is the case.",
        "edited": {
            "user": "U1BC5A0F9",
            "ts": "1486057277.000000"
        },
        "ts": "1486057252.000024"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "b) The same as what Matthias (<@U2GFYLYN8>) mentioned before: with the new deployment model the isolation between chains is weakened by having one chaincode instance handle multiple chains. In the presence of an attacker that can compromise chaincode by invoking it, such an attacker would thus gain access to all chains that the chaincode is being used for.",
        "ts": "1486057430.000026"
    },
    {
        "type": "message",
        "user": "U2GFYLYN8",
        "text": "<@U1BC5A0F9> thanks a lot for the write-up! :slightly_smiling_face:",
        "ts": "1486057798.000027",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U0ULK2JPP"
                ],
                "count": 1
            }
        ]
    },
    {
        "type": "message",
        "user": "U0ULK2JPP",
        "text": "Will read by today Elli (and thanks Matthias!)",
        "edited": {
            "user": "U0ULK2JPP",
            "ts": "1486057921.000000"
        },
        "ts": "1486057896.000028"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "c) The chaincodes are not authenticated in their connection to the peer. Meaning that the chaincode - peer connection is solely peer-side authenticated. This is *not a problem* for as long as the connection that the peer initiates for that chaincode is open. If for any reason the connection to more than one chaincodes is closed (unnexpectedly) the peer will try to re-connect to both chaincodes. Then because connections are not authenticated from the chaincode side, there is an ability of one chaincode to impersonate the other. This can be avoided if we have tls certificates inside the containers, and leverage mutual authentication.",
        "ts": "1486057905.000029"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "<@U2GFYLYN8>, thank you for your time and advice !",
        "edited": {
            "user": "U1BC5A0F9",
            "ts": "1486058128.000000"
        },
        "ts": "1486057918.000030"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "<@U0ULK2JPP>, at your convenience :slightly_smiling_face:",
        "ts": "1486057953.000032"
    },
    {
        "type": "message",
        "user": "U1BC5A0F9",
        "text": "d) Finally, a note for us to check: is there a possibility for a malicious chaincode to impersonate another one before the connection of a peer to a freshly launched chaincode is established?",
        "ts": "1486058322.000034"
    },
    {
        "user": "U3D5886CB",
        "text": "<@U3D5886CB|ruslan> has joined the channel",
        "type": "message",
        "subtype": "channel_join",
        "ts": "1486065155.000035"
    }
]